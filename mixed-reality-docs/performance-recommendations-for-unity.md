---
title: Raccomandazioni sulle prestazioni per Unity
description: Suggerimenti specifici del Unity per migliorare le prestazioni con le app di realtà mista.
author: Troy-Ferrell
ms.author: trferrel
ms.date: 03/26/2019
ms.topic: article
keywords: gli elementi grafici, cpu, gpu, il rendering, la garbage collection, hololens
ms.openlocfilehash: b0821f07184bff8630f6b6af0d0fc461f6fcd133
ms.sourcegitcommit: 8f3ff9738397d9b9fdf4703b14b89d416f0186a5
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 07/12/2019
ms.locfileid: "67843339"
---
# <a name="performance-recommendations-for-unity"></a><span data-ttu-id="5be8d-104">Raccomandazioni sulle prestazioni per Unity</span><span class="sxs-lookup"><span data-stu-id="5be8d-104">Performance recommendations for Unity</span></span>

<span data-ttu-id="5be8d-105">Questo articolo si basa sulla discussione descritta nella [raccomandazioni sulle prestazioni per realtà mista](understanding-performance-for-mixed-reality.md) ma si concentra su informazioni specifiche per l'ambiente di motore Unity.</span><span class="sxs-lookup"><span data-stu-id="5be8d-105">This article builds on the discussion outlined in [performance recommendations for mixed reality](understanding-performance-for-mixed-reality.md) but focuses on learnings specific to the Unity engine environment.</span></span>

<span data-ttu-id="5be8d-106">È anche consigliabile che gli sviluppatori di rivedere le [consigliati delle impostazioni di ambiente per l'articolo di Unity](Recommended-settings-for-unity.md).</span><span class="sxs-lookup"><span data-stu-id="5be8d-106">It is also highly advisable that developers review the [recommended environment settings for Unity article](Recommended-settings-for-unity.md).</span></span> <span data-ttu-id="5be8d-107">Questo articolo offre contenuti con alcune delle configurazioni di scena più importanti in merito alla creazione di App di realtà mista ad alte prestazioni.</span><span class="sxs-lookup"><span data-stu-id="5be8d-107">This article has content with some of the most important scene configurations in regards to building performant Mixed Reality apps.</span></span> <span data-ttu-id="5be8d-108">Alcune di queste impostazioni consigliate vengono evidenziate anche di seguito.</span><span class="sxs-lookup"><span data-stu-id="5be8d-108">Some of these recommended settings are highlighted below as well.</span></span>

## <a name="how-to-profile-with-unity"></a><span data-ttu-id="5be8d-109">Come eseguire la profilatura con Unity</span><span class="sxs-lookup"><span data-stu-id="5be8d-109">How to profile with Unity</span></span>

<span data-ttu-id="5be8d-110">Unity offre il **[Profiler di Unity](https://docs.unity3d.com/Manual/Profiler.html)** predefinite che è un'ottima risorsa per raccogliere informazioni dettagliate preziose sulle prestazioni per l'app specifica.</span><span class="sxs-lookup"><span data-stu-id="5be8d-110">Unity provides the **[Unity Profiler](https://docs.unity3d.com/Manual/Profiler.html)** built-in which is a great resource to gather valuable performance insights for your particular app.</span></span> <span data-ttu-id="5be8d-111">Anche se sarà possibile eseguire il profiler nell'editor, queste metriche non rappresentano l'ambiente di runtime true e di conseguenza, i risultati da questo oggetto devono essere utilizzati con cautela.</span><span class="sxs-lookup"><span data-stu-id="5be8d-111">Although one can run the profiler in-editor, these metrics do not represent the true runtime environment and thus, results from this should be used cautiously.</span></span> <span data-ttu-id="5be8d-112">È consigliabile profilare in modalità remota dell'applicazione durante l'esecuzione nel dispositivo per informazioni dettagliate più accurate e utilizzabili.</span><span class="sxs-lookup"><span data-stu-id="5be8d-112">It is recommended to remotely profile your application while running on device for most accurate and actionable insights.</span></span> <span data-ttu-id="5be8d-113">Inoltre, di Unity [Frame Debugger](https://docs.unity3d.com/Manual/FrameDebugger.html) è anche molto potente e strumento informazioni dettagliate da utilizzare.</span><span class="sxs-lookup"><span data-stu-id="5be8d-113">Further, Unity's [Frame Debugger](https://docs.unity3d.com/Manual/FrameDebugger.html)  is also a very powerful and insight tool to utilize.</span></span>

<span data-ttu-id="5be8d-114">Unity offre documentazione molto utile per:</span><span class="sxs-lookup"><span data-stu-id="5be8d-114">Unity provides great documentation for:</span></span>
1) <span data-ttu-id="5be8d-115">Come connettere il [profiler di Unity per le applicazioni UWP in modalità remota](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span><span class="sxs-lookup"><span data-stu-id="5be8d-115">How to connect the [Unity profiler to UWP applications remotely](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span></span>
2) <span data-ttu-id="5be8d-116">Come in modo efficace [diagnosticare i problemi di prestazioni con il Profiler di Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span><span class="sxs-lookup"><span data-stu-id="5be8d-116">How to effectively [diagnose performance problems with the Unity Profiler](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span></span>

>[!NOTE]
> <span data-ttu-id="5be8d-117">Con il Profiler di Unity connessi e dopo l'aggiunta del profiler GPU (vedere *Profiler aggiungere* nell'angolo superiore destro), si possono osservare quanto viene impiegato il tempo della CPU & GPU rispettivamente al centro del profiler.</span><span class="sxs-lookup"><span data-stu-id="5be8d-117">With the Unity Profiler connected and after adding the GPU profiler (see *Add Profiler* in top right corner), one can see how much time is being spent on the CPU & GPU respectively in the middle of the profiler.</span></span> <span data-ttu-id="5be8d-118">Questo consente allo sviluppatore di ottenere un'approssimazione rapida se l'applicazione della CPU o GPU delimitato.</span><span class="sxs-lookup"><span data-stu-id="5be8d-118">This allows the developer to get a quick approximation if their application is CPU or GPU bounded.</span></span>
>
> ![CPU di Unity per vs GPU](images/unity-profiler-cpu-gpu.png)

## <a name="cpu-performance-recommendations"></a><span data-ttu-id="5be8d-120">Raccomandazioni per le prestazioni della CPU</span><span class="sxs-lookup"><span data-stu-id="5be8d-120">CPU performance recommendations</span></span>

<span data-ttu-id="5be8d-121">Il contenuto seguente vengono illustrate altre procedure consigliate approfondite ad alte prestazioni, destinate in particolare per Unity & C# sviluppo.</span><span class="sxs-lookup"><span data-stu-id="5be8d-121">The content below covers more in-depth performance practices, especially targeted for Unity & C# development.</span></span>

#### <a name="cache-references"></a><span data-ttu-id="5be8d-122">Riferimenti cache</span><span class="sxs-lookup"><span data-stu-id="5be8d-122">Cache references</span></span>

<span data-ttu-id="5be8d-123">È consigliabile i riferimenti a tutti i componenti pertinenti e Gameobject in fase di inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="5be8d-123">It is best practice to cache references to all relevant components and GameObjects at initialization.</span></span> <span data-ttu-id="5be8d-124">Infatti, ripetere le chiamate di funzione, ad esempio *[GetComponent\<T > ()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* sono molto più costoso rispetto alla memoria di costo per archiviare un puntatore.</span><span class="sxs-lookup"><span data-stu-id="5be8d-124">This is because repeating function calls such as *[GetComponent\<T>()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* are significantly more expensive relative to the memory cost to store a pointer.</span></span> <span data-ttu-id="5be8d-125">Questo vale anche per a di molto, regolarmente usati [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html).</span><span class="sxs-lookup"><span data-stu-id="5be8d-125">This also applies to to the very, regularly used [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html).</span></span> <span data-ttu-id="5be8d-126">*Camera.Main* semplicemente Usa *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* sotto il grafico della scena per un oggetto della fotocamera con un costo esegue la ricerca di *"MainCamera"*  tag.</span><span class="sxs-lookup"><span data-stu-id="5be8d-126">*Camera.main* actually just uses *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* underneath which expensively searches your scene graph for a camera object with the *"MainCamera"* tag.</span></span>

```CS
using UnityEngine;
using System.Collections;

public class ExampleClass : MonoBehaviour
{
    private Camera cam;
    private CustomComponent comp;

    void Start() 
    {
        cam = Camera.main;
        comp = GetComponent<CustomComponent>();
    }

    void Update()
    {
        // Good
        this.transform.position = cam.transform.position + cam.transform.forward * 10.0f;

        // Bad
        this.transform.position = Camera.main.transform.position + Camera.main.transform.forward * 10.0f;

        // Good
        comp.DoSomethingAwesome();

        // Bad
        GetComponent<CustomComponent>().DoSomethingAwesome();
    }
}
```

>[!NOTE] 
> <span data-ttu-id="5be8d-127">Evitare GetComponent(string)</span><span class="sxs-lookup"><span data-stu-id="5be8d-127">Avoid GetComponent(string)</span></span> <br/>
> <span data-ttu-id="5be8d-128">Quando si usa  *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* , esistono una vasta gamma di overload differenti.</span><span class="sxs-lookup"><span data-stu-id="5be8d-128">When using *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)*, there are a handful of different overloads.</span></span> <span data-ttu-id="5be8d-129">È importante usare sempre le implementazioni di tipo di base e mai l'overload di ricerca basate su stringa.</span><span class="sxs-lookup"><span data-stu-id="5be8d-129">It is important to always use the Type based implementations and never the string-based searching overload.</span></span> <span data-ttu-id="5be8d-130">La ricerca dalla stringa nella scena è notevolmente più costosa rispetto alla ricerca in base al tipo.</span><span class="sxs-lookup"><span data-stu-id="5be8d-130">Searching by string in your scene is significantly more costly than searching by Type.</span></span> <br/>
> <span data-ttu-id="5be8d-131">(Valido) Componente GetComponent (tipo tipo)</span><span class="sxs-lookup"><span data-stu-id="5be8d-131">(Good) Component GetComponent(Type type)</span></span> <br/>
> <span data-ttu-id="5be8d-132">(Valido) T GetComponent\<T >)</span><span class="sxs-lookup"><span data-stu-id="5be8d-132">(Good) T GetComponent\<T>()</span></span> <br/>
> <span data-ttu-id="5be8d-133">(Negativo) Componente GetComponent(string) ></span><span class="sxs-lookup"><span data-stu-id="5be8d-133">(Bad) Component GetComponent(string)></span></span> <br/>

#### <a name="avoid-expensive-operations"></a><span data-ttu-id="5be8d-134">Evitare operazioni costose</span><span class="sxs-lookup"><span data-stu-id="5be8d-134">Avoid expensive operations</span></span>

1) <span data-ttu-id="5be8d-135">**Evitare l'uso di [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span><span class="sxs-lookup"><span data-stu-id="5be8d-135">**Avoid use of [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span></span>

    <span data-ttu-id="5be8d-136">Sebbene LINQ può essere molto pulito e facile da leggere e scrivere, in genere richiede molto più calcoli e più in particolare allocazione di memoria rispetto alla scrittura manualmente l'algoritmo.</span><span class="sxs-lookup"><span data-stu-id="5be8d-136">Although LINQ can be very clean and easy to read and write, it generally requires much more computation and particularly more memory allocation than writing the algorithm out manually.</span></span>

    ```CS
    // Example Code
    using System.Linq;

    List<int> data = new List<int>();
    data.Any(x => x > 10);

    var result = from x in data
                 where x > 10
                 select x;
    ```

2) <span data-ttu-id="5be8d-137">**API comuni di Unity**</span><span class="sxs-lookup"><span data-stu-id="5be8d-137">**Common Unity APIs**</span></span>

    <span data-ttu-id="5be8d-138">Alcune API di Unity, sebbene utile, può risultare dispendiosa da eseguire.</span><span class="sxs-lookup"><span data-stu-id="5be8d-138">Certain Unity APIs, although useful, can be very expensive to execute.</span></span> <span data-ttu-id="5be8d-139">La maggior parte di questi implica la ricerca del grafico della scena intera per un elenco di Gameobject corrispondenti.</span><span class="sxs-lookup"><span data-stu-id="5be8d-139">Most of these involve searching your entire scene graph for some matching list of GameObjects.</span></span> <span data-ttu-id="5be8d-140">Queste operazioni possono essere evitate in genere la memorizzazione nella cache i riferimenti o implementando un componente di gestione per il Gameobject in questione rilevare i riferimenti in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="5be8d-140">These operations can generally be avoided by caching references or implementing a manager component for the GameObjects in question to track the references at runtime.</span></span>

        GameObject.SendMessage()
        GameObject.BroadcastMessage()
        UnityEngine.Object.Find()
        UnityEngine.Object.FindWithTag()
        UnityEngine.Object.FindObjectOfType()
        UnityEngine.Object.FindObjectsOfType()
        UnityEngine.Object.FindGameObjectsWithTag()
        UnityEngine.Object.FindGameObjectsWithTag()

>[!NOTE]
> <span data-ttu-id="5be8d-141">*[SendMessage ()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)*  e *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* dovrebbero essere eliminate a tutti i costi.</span><span class="sxs-lookup"><span data-stu-id="5be8d-141">*[SendMessage()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* and *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* should be eliminated at all costs.</span></span> <span data-ttu-id="5be8d-142">Queste funzioni possono essere nell'ordine di 1000 x più lento rispetto alle chiamate di funzione diretta.</span><span class="sxs-lookup"><span data-stu-id="5be8d-142">These functions can be on the order of 1000x slower than direct function calls.</span></span>

3) <span data-ttu-id="5be8d-143">**Prestare attenzione della conversione boxing**</span><span class="sxs-lookup"><span data-stu-id="5be8d-143">**Beware of boxing**</span></span>

    <span data-ttu-id="5be8d-144">[La conversione boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) è un concetto fondamentale del C# runtime e linguaggio.</span><span class="sxs-lookup"><span data-stu-id="5be8d-144">[Boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) is a core concept of the C# language and runtime.</span></span> <span data-ttu-id="5be8d-145">È il processo di ritorno a capo nelle variabili di tipo reference valori variabili, ad esempio char, int, bool e così via.</span><span class="sxs-lookup"><span data-stu-id="5be8d-145">It is the process of wrapping value-typed variables such as char, int, bool, etc. into reference-typed variables.</span></span> <span data-ttu-id="5be8d-146">Quando una variabile di valore tipizzato è "boxing", vengono incapsulati all'interno di un System. Object, che viene archiviato nell'heap gestito.</span><span class="sxs-lookup"><span data-stu-id="5be8d-146">When a value-typed variable is "boxed", it is wrapped inside of a System.Object which is stored on the managed heap.</span></span> <span data-ttu-id="5be8d-147">Di conseguenza, la memoria viene allocata e alla fine quando eliminata devono essere elaborate dal garbage collector.</span><span class="sxs-lookup"><span data-stu-id="5be8d-147">Thus, memory is allocated and eventually when disposed must be processed by the garbage collector.</span></span> <span data-ttu-id="5be8d-148">Queste allocazioni e deallocazioni comportano una riduzione delle prestazioni e in molti scenari non sono necessari o possono essere facilmente sostituite da un'alternativa meno costosa.</span><span class="sxs-lookup"><span data-stu-id="5be8d-148">These allocations and deallocations incur a performance cost and in many scenarios are unnecessary or can be easily replaced by a less expensive alternative.</span></span>

#### <a name="repeating-code-paths"></a><span data-ttu-id="5be8d-149">Ripetere i percorsi del codice</span><span class="sxs-lookup"><span data-stu-id="5be8d-149">Repeating code paths</span></span>

<span data-ttu-id="5be8d-150">Qualsiasi funzione di callback di Unity (ad esempio ripetuti</span><span class="sxs-lookup"><span data-stu-id="5be8d-150">Any repeating Unity callback functions (i.e</span></span> <span data-ttu-id="5be8d-151">Aggiornamento) che vengono eseguite molte volte al secondo e/o frame deve essere scritti con estrema cautela.</span><span class="sxs-lookup"><span data-stu-id="5be8d-151">Update) that are executed many times per second and/or frame should be written very carefully.</span></span> <span data-ttu-id="5be8d-152">Operazioni dispendiose qui avrà enorme e coerenti con l'impatto sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="5be8d-152">Any expensive operations here will have huge and consistent impact on performance.</span></span>

1) <span data-ttu-id="5be8d-153">**Funzioni di callback vuoto**</span><span class="sxs-lookup"><span data-stu-id="5be8d-153">**Empty callback functions**</span></span>

    <span data-ttu-id="5be8d-154">Anche se può sembrare innocente a lasciare nell'applicazione, soprattutto perché ogni Unity script automatico inizializza con il blocco di codice, il codice riportato di seguito questi callback vuoti possono effettivamente diventare molto costosi.</span><span class="sxs-lookup"><span data-stu-id="5be8d-154">Although the code below may seem innocent to leave in your application, especially since every Unity script auto-initializes with this code block, these empty callbacks can actually become very expensive.</span></span> <span data-ttu-id="5be8d-155">Unity opera e viceversa attraverso un limite di codice non gestita/gestita, tra codice UnityEngine e il codice dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="5be8d-155">Unity operates back and forth over an unmanaged/managed code boundary, between UnityEngine code and your application code.</span></span> <span data-ttu-id="5be8d-156">Tramite questo bridge il cambio di contesto è piuttosto dispendioso, anche se non c'è niente da eseguire.</span><span class="sxs-lookup"><span data-stu-id="5be8d-156">Context switching over this bridge is fairly expensive even if there is nothing to execute.</span></span> <span data-ttu-id="5be8d-157">Ciò risulta particolarmente problematico se l'app contiene centinaia di Gameobject con componenti che devono vuoto i callback di Unity ripetuti.</span><span class="sxs-lookup"><span data-stu-id="5be8d-157">This becomes especially problematic if your app has 100's of GameObjects with components that have empty repeating Unity callbacks.</span></span>

    ```CS
    void Update()
    {
    }
    ```

>[!NOTE]
> <span data-ttu-id="5be8d-158">Update () è la manifestazione più comune di questo problema di prestazioni, ma altri callback Unity ripetuti, ad esempio di seguito possono essere ugualmente errata se non peggiore: FixedUpdate(), LateUpdate(), OnPostRender", OnPreRender(), OnRenderImage(), etc.</span><span class="sxs-lookup"><span data-stu-id="5be8d-158">Update() is the most common manifestation of this performance issue but other repeating Unity callbacks such as the following can be equally as bad if not worse: FixedUpdate(), LateUpdate(), OnPostRender", OnPreRender(), OnRenderImage(), etc.</span></span> 

2) <span data-ttu-id="5be8d-159">**Operazioni per favorire la riduzione in esecuzione una sola volta per ogni fotogramma**</span><span class="sxs-lookup"><span data-stu-id="5be8d-159">**Operations to favor running once per frame**</span></span>

    <span data-ttu-id="5be8d-160">Le seguenti API di Unity sono operazioni comuni per molte App Holographic.</span><span class="sxs-lookup"><span data-stu-id="5be8d-160">The following Unity APIs are common operations for many Holographic Apps.</span></span> <span data-ttu-id="5be8d-161">Anche se non è sempre possibile, i risultati di queste funzioni molto di frequente possono essere calcolati una volta e i risultati nuovamente utilizzata in tutta l'applicazione per un determinato intervallo.</span><span class="sxs-lookup"><span data-stu-id="5be8d-161">Although not always possible, the results from these functions can very commonly be computed once and the results re-utilized across the application for a given frame.</span></span>

    <span data-ttu-id="5be8d-162">a) a livello generale è consigliabile avere una classe Singleton o gestire lo sguardo Raycast nella scena e quindi riutilizzare questo risultato in tutti gli altri componenti di scena, invece di effettuare operazioni Raycast ripetute ed essenzialmente identiche da ogni servizio dedicato componente.</span><span class="sxs-lookup"><span data-stu-id="5be8d-162">a) Generally it is good practice to have a dedicated Singleton class or service to handle your gaze Raycast into the scene and then re-use this result in all other scene components, instead of making repeated and essentially identical Raycast operations by each component.</span></span> <span data-ttu-id="5be8d-163">Naturalmente, è possibile che alcune applicazioni richiedano raycasts da origini diverse o con diversi [LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span><span class="sxs-lookup"><span data-stu-id="5be8d-163">Of course, some applications may require raycasts from different origins or against different [LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span></span>

        UnityEngine.Physics.Raycast()
        UnityEngine.Physics.RaycastAll()

    <span data-ttu-id="5be8d-164">b) GetComponent() operazioni ripetute di callback di Unity come Update () per evitare [memorizzazione nella cache i riferimenti](#cache-references) in Start () o Awake()</span><span class="sxs-lookup"><span data-stu-id="5be8d-164">b) Avoid GetComponent() operations in repeated Unity callbacks like Update() by [caching references](#cache-references) in Start() or Awake()</span></span>

        UnityEngine.Object.GetComponent()

    <span data-ttu-id="5be8d-165">c) è consigliabile creare un'istanza di tutti gli oggetti, se possibile, inizializzazione e di utilizzo [pool di oggetti](#object-pooling) per riciclare e riutilizzare Gameobject in fase di esecuzione dell'applicazione</span><span class="sxs-lookup"><span data-stu-id="5be8d-165">c) It is good practice to instantiate all objects, if possible, at initialization and use [object pooling](#object-pooling) to recycle and re-use GameObjects throughout runtime of your application</span></span>

        UnityEngine.Object.Instantiate()

3) <span data-ttu-id="5be8d-166">**Evitare interfacce e costrutti virtuali**</span><span class="sxs-lookup"><span data-stu-id="5be8d-166">**Avoid interfaces and virtual constructs**</span></span>

    <span data-ttu-id="5be8d-167">Chiamate di funzione tramite oggetti diretti di interfacce Visual Studio o la chiamata di funzioni virtuali può spesso essere notevolmente più costoso che usano costrutti diretti o chiamate di funzione diretta.</span><span class="sxs-lookup"><span data-stu-id="5be8d-167">Invoking function calls through interfaces vs direct objects or calling virtual functions can often times be much more expensive than utilizing direct constructs or direct function calls.</span></span> <span data-ttu-id="5be8d-168">Se la funzione virtuale o l'interfaccia è necessaria, deve essere rimossa.</span><span class="sxs-lookup"><span data-stu-id="5be8d-168">If the virtual function or interface is unnecessary, then it should be removed.</span></span> <span data-ttu-id="5be8d-169">Tuttavia, le prestazioni riscontri per questi approcci sono in genere è la pena di compromesso se che li usano semplifica la collaborazione di sviluppo, la leggibilità del codice e la gestibilità del codice.</span><span class="sxs-lookup"><span data-stu-id="5be8d-169">However, the performance hit for these approaches are generally worth the trade-off if utilizing them simplifies development collaboration, code readability, and code maintainability.</span></span> 

4) <span data-ttu-id="5be8d-170">**Evitare gli struct di passaggio per valore**</span><span class="sxs-lookup"><span data-stu-id="5be8d-170">**Avoid passing structs by value**</span></span>

    <span data-ttu-id="5be8d-171">A differenza delle classi, struct sono tipi di valore e quando viene passato direttamente a una funzione, i relativi contenuti vengono copiati in un'istanza appena creata.</span><span class="sxs-lookup"><span data-stu-id="5be8d-171">Unlike classes, structs are value-types and when passed directly to a function, their contents are copied into a newly created instance.</span></span> <span data-ttu-id="5be8d-172">Questa copia aggiunge della CPU, nonché memoria aggiuntiva nello stack.</span><span class="sxs-lookup"><span data-stu-id="5be8d-172">This copy adds CPU cost as well as additional memory on the stack.</span></span> <span data-ttu-id="5be8d-173">Per gli struct di piccole dimensioni, l'effetto è in genere molto limitate e pertanto accettabili.</span><span class="sxs-lookup"><span data-stu-id="5be8d-173">For small structs, the effect is usually very minimal and thus acceptable.</span></span> <span data-ttu-id="5be8d-174">Tuttavia, per le funzioni richiamato più volte per ogni fotogramma, nonché le funzioni richiede le strutture di grandi dimensioni, se possibile modificare la definizione di funzione venga passato per riferimento.</span><span class="sxs-lookup"><span data-stu-id="5be8d-174">However, for functions repeatedly invoked every frame as well as functions taking large structs, if possible modify the function definition to pass by reference.</span></span> [<span data-ttu-id="5be8d-175">Altre informazioni sono disponibili qui</span><span class="sxs-lookup"><span data-stu-id="5be8d-175">Learn more here</span></span>](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/how-to-know-the-difference-passing-a-struct-and-passing-a-class-to-a-method)

#### <a name="miscellaneous"></a><span data-ttu-id="5be8d-176">Miscellaneous</span><span class="sxs-lookup"><span data-stu-id="5be8d-176">Miscellaneous</span></span>

1) <span data-ttu-id="5be8d-177">**Fisica**</span><span class="sxs-lookup"><span data-stu-id="5be8d-177">**Physics**</span></span>

    <span data-ttu-id="5be8d-178">a) il modo più semplice per migliorare la fisica è a livello generale, per limitare la quantità di tempo trascorso in fisica o il numero di iterazioni al secondo.</span><span class="sxs-lookup"><span data-stu-id="5be8d-178">a) Generally, easiest way to improve physics is to limit the amount of time spent on Physics or the number of iterations per second.</span></span> <span data-ttu-id="5be8d-179">Naturalmente, ciò riduce la precisione di simulazione.</span><span class="sxs-lookup"><span data-stu-id="5be8d-179">Of course, this will reduce simulation accuracy.</span></span> <span data-ttu-id="5be8d-180">Visualizzare [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) in Unity</span><span class="sxs-lookup"><span data-stu-id="5be8d-180">See [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) in Unity</span></span>

    <span data-ttu-id="5be8d-181">b) il tipo di colliders in Unity sono ampiamente diverse caratteristiche di prestazioni.</span><span class="sxs-lookup"><span data-stu-id="5be8d-181">b) The type of colliders in Unity have widely different performance characteristics.</span></span> <span data-ttu-id="5be8d-182">L'ordine riportato di seguito sono elencate le maggior parte delle colliders ad alte prestazioni per almeno colliders ad alte prestazioni da sinistra a destra.</span><span class="sxs-lookup"><span data-stu-id="5be8d-182">The order below lists the most performant colliders to least performant colliders from left to right.</span></span> <span data-ttu-id="5be8d-183">È molto importante evitare Colliders Mesh che sono notevolmente più costoso il colliders primitivo.</span><span class="sxs-lookup"><span data-stu-id="5be8d-183">It is most important to avoid Mesh Colliders which are substantially more expensive than the primitive colliders.</span></span>

        Sphere < Capsule < Box <<< Mesh (Convex) < Mesh (non-Convex)

    <span data-ttu-id="5be8d-184">Visualizzare [Unity fisica consigliate](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) per altre informazioni</span><span class="sxs-lookup"><span data-stu-id="5be8d-184">See [Unity Physics Best Practices](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) for more info</span></span>

2) <span data-ttu-id="5be8d-185">**Animazioni**</span><span class="sxs-lookup"><span data-stu-id="5be8d-185">**Animations**</span></span>

    <span data-ttu-id="5be8d-186">Disabilitare le animazioni inattività disabilitando il componente animatore (disabilitazione l'oggetto gioco non hanno lo stesso effetto).</span><span class="sxs-lookup"><span data-stu-id="5be8d-186">Disable idle animations by disabling the Animator component (disabling the game object won't have the same effect).</span></span> <span data-ttu-id="5be8d-187">Evitare di modelli di progettazione in cui un animatore si trova in un ciclo impostando un valore per la stessa cosa.</span><span class="sxs-lookup"><span data-stu-id="5be8d-187">Avoid design patterns where an animator sits in a loop setting a value to the same thing.</span></span> <span data-ttu-id="5be8d-188">È un notevole sovraccarico per questa tecnica, senza alcun effetto sull'applicazione.</span><span class="sxs-lookup"><span data-stu-id="5be8d-188">There is considerable overhead for this technique, with no effect on the application.</span></span> [<span data-ttu-id="5be8d-189">Altre informazioni sono disponibili qui.</span><span class="sxs-lookup"><span data-stu-id="5be8d-189">Learn more here.</span></span>](https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html)

3) <span data-ttu-id="5be8d-190">**Algoritmi complessi**</span><span class="sxs-lookup"><span data-stu-id="5be8d-190">**Complex algorithms**</span></span>

    <span data-ttu-id="5be8d-191">Se l'applicazione usa algoritmi complessi, ad esempio cinematica inversa, ricerca di percorso, e così via, ricerca per trovare un approccio più semplice o modificare le impostazioni rilevanti per le prestazioni</span><span class="sxs-lookup"><span data-stu-id="5be8d-191">If your application is using complex algorithms such as inverse kinematics, path finding, etc, look to find a simpler approach or adjust relevant settings for their performance</span></span>

## <a name="cpu-to-gpu-performance-recommendations"></a><span data-ttu-id="5be8d-192">Raccomandazioni per le prestazioni della CPU-a-GPU</span><span class="sxs-lookup"><span data-stu-id="5be8d-192">CPU-to-GPU performance recommendations</span></span>

<span data-ttu-id="5be8d-193">In genere, le prestazioni della CPU-a-GPU deduce il **le chiamate di disegno** inviato a una scheda grafica.</span><span class="sxs-lookup"><span data-stu-id="5be8d-193">Generally, CPU-to-GPU performance comes down to the **draw calls** submitted to the graphics card.</span></span> <span data-ttu-id="5be8d-194">Per migliorare le prestazioni, devono essere in modo strategico le chiamate di disegno **a) ridotta** oppure **b) ristrutturato** per ottenere risultati ottimali.</span><span class="sxs-lookup"><span data-stu-id="5be8d-194">To improve performance, draw calls need to be strategically **a) reduced** or **b) restructured** for optimal results.</span></span> <span data-ttu-id="5be8d-195">Poiché le chiamate di disegno stessi sono a elevato utilizzo di risorse, riducendo le ridurrà complessiva lavoro richiesto.</span><span class="sxs-lookup"><span data-stu-id="5be8d-195">Since draw calls themselves are resource-intensive, reducing them will reduce overall work required.</span></span> <span data-ttu-id="5be8d-196">Inoltre, lo stato delle modifiche tra le chiamate di disegno richiede la convalida costosa e di passaggi di traduzione dei driver di grafica e di conseguenza, la ristrutturazione delle chiamate di disegno dell'applicazione per limitare le modifiche dello stato (ad es.</span><span class="sxs-lookup"><span data-stu-id="5be8d-196">Further, state changes between draw calls requires costly validation and translation steps in the graphics driver and thus, restructuring of your application's draw calls to limit state changes(i.e</span></span> <span data-ttu-id="5be8d-197">diversi materiali e così via) può migliorare le prestazioni.</span><span class="sxs-lookup"><span data-stu-id="5be8d-197">different materials, etc) can boost performance.</span></span>

<span data-ttu-id="5be8d-198">Unity è un articolo eccezionale che offra una panoramica e approfondisce l'invio in batch le chiamate di disegno per la propria piattaforma.</span><span class="sxs-lookup"><span data-stu-id="5be8d-198">Unity has a great article that gives an overview and dives into batching draw calls for their platform.</span></span>
- [<span data-ttu-id="5be8d-199">Unity disegnare chiamata di invio in batch</span><span class="sxs-lookup"><span data-stu-id="5be8d-199">Unity Draw Call Batching</span></span>](https://docs.unity3d.com/Manual/DrawCallBatching.html)

#### <a name="single-pass-instanced-rendering"></a><span data-ttu-id="5be8d-200">Rendering singola istanza</span><span class="sxs-lookup"><span data-stu-id="5be8d-200">Single pass instanced rendering</span></span>

<span data-ttu-id="5be8d-201">Grazie al passaggio singolo Instanced Rendering in Unity per le chiamate di disegno per ogni occhio venga ridotta fino alla chiamata di disegno istanza uno.</span><span class="sxs-lookup"><span data-stu-id="5be8d-201">Single Pass Instanced Rendering in Unity allows for draw calls for each eye to be reduced down to one instanced draw call.</span></span> <span data-ttu-id="5be8d-202">A causa della coerenza della cache tra due chiamate di disegno, è inoltre disponibile un miglioramento delle prestazioni nella GPU anche.</span><span class="sxs-lookup"><span data-stu-id="5be8d-202">Due to cache coherency between two draw calls, there is also some performance improvement on the GPU as well.</span></span>

<span data-ttu-id="5be8d-203">Per abilitare questa funzionalità nel progetto Unity</span><span class="sxs-lookup"><span data-stu-id="5be8d-203">To enable this feature in your Unity Project</span></span>
1)  <span data-ttu-id="5be8d-204">Open **le impostazioni del giocatore XR** (Vai al **modifica** > **impostazioni progetto** > **Player**  >  **XR impostazioni**)</span><span class="sxs-lookup"><span data-stu-id="5be8d-204">Open **Player XR Settings** (go to **Edit** > **Project Settings** > **Player** > **XR Settings**)</span></span>
2) <span data-ttu-id="5be8d-205">Selezionare **singola istanza di passare** dal **Stereo metodo di Rendering** dal menu a discesa (**supportato di realtà virtuale** deve essere selezionata la casella di controllo)</span><span class="sxs-lookup"><span data-stu-id="5be8d-205">Select **Single Pass Instanced** from the **Stereo Rendering Method** drop-down menu (**Virtual Reality Supported** checkbox must be checked)</span></span>

<span data-ttu-id="5be8d-206">Per informazioni dettagliate con questo approccio per il rendering, leggere gli articoli seguenti da Unity.</span><span class="sxs-lookup"><span data-stu-id="5be8d-206">Read the following articles from Unity for details with this rendering approach.</span></span>
- [<span data-ttu-id="5be8d-207">Come ottimizzare le prestazioni di AR e VR con rendering stereo avanzate</span><span class="sxs-lookup"><span data-stu-id="5be8d-207">How to maximize AR and VR performance with advanced stereo rendering</span></span>](https://blogs.unity3d.com/2017/11/21/how-to-maximize-ar-and-vr-performance-with-advanced-stereo-rendering/)
- [<span data-ttu-id="5be8d-208">Creazione di istanze di passaggio singolo</span><span class="sxs-lookup"><span data-stu-id="5be8d-208">Single Pass Instancing</span></span>](https://docs.unity3d.com/Manual/SinglePassInstancing.html) 

>[!NOTE]
> <span data-ttu-id="5be8d-209">Si verifica un problema comune relativo all'unico passare istanze per il Rendering se sviluppatori dispongono già di shader personalizzati esistenti non scritti per la creazione di istanze.</span><span class="sxs-lookup"><span data-stu-id="5be8d-209">One common issue with Single Pass Instanced Rendering occurs if developers already have existing custom shaders not written for instancing.</span></span> <span data-ttu-id="5be8d-210">Dopo aver abilitato questa funzionalità, gli sviluppatori potrebbero notare alcuni Gameobject solo eseguire il rendering in un occhio.</span><span class="sxs-lookup"><span data-stu-id="5be8d-210">After enabling this feature, developers may notice some GameObjects only render in one eye.</span></span> <span data-ttu-id="5be8d-211">Infatti, gli shader personalizzati associati non hanno le proprietà appropriate per la creazione di istanze.</span><span class="sxs-lookup"><span data-stu-id="5be8d-211">This is because the associated custom shaders do not have the appropriate properties for instancing.</span></span>
>
> <span data-ttu-id="5be8d-212">Visualizzare [singolo passare Stereo Rendering per HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) da Unity per la procedura risolvere questo problema</span><span class="sxs-lookup"><span data-stu-id="5be8d-212">See [Single Pass Stereo Rendering for HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) from Unity for how to address this problem</span></span>

#### <a name="static-batching"></a><span data-ttu-id="5be8d-213">L'invio in batch statico</span><span class="sxs-lookup"><span data-stu-id="5be8d-213">Static batching</span></span>

<span data-ttu-id="5be8d-214">Unity è in grado di inviare in batch numerosi oggetti statici per ridurre le chiamate di disegno nella GPU.</span><span class="sxs-lookup"><span data-stu-id="5be8d-214">Unity is able to batch many static objects to reduce draw calls to the GPU.</span></span> <span data-ttu-id="5be8d-215">L'invio in batch statica funziona per la maggior parte [Renderer](https://docs.unity3d.com/ScriptReference/Renderer.html) gli oggetti in Unity che **1) condividono lo stesso materiale** e **2) sono tutte contrassegnate come *statico***  ( Selezionare un oggetto in Unity e selezionare la casella di controllo nella parte superiore destra della finestra di ispezione).</span><span class="sxs-lookup"><span data-stu-id="5be8d-215">Static Batching works for most [Renderer](https://docs.unity3d.com/ScriptReference/Renderer.html) objects in Unity that **1) share the same material** and **2) are all marked as *Static*** (Select an object in Unity and click the checkbox in the top right of the inspector).</span></span> <span data-ttu-id="5be8d-216">Gameobject contrassegnato come *statici* non possono essere spostati in fase di esecuzione dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="5be8d-216">GameObjects marked as *Static* cannot be moved throughout your application's runtime.</span></span> <span data-ttu-id="5be8d-217">Di conseguenza, può essere difficile sfruttare su HoloLens in cui deve essere inserita, spostati, ridimensionati, e così via praticamente tutti gli oggetti statici di invio in batch. Per immersive auricolari, l'invio in batch statico può ridurre notevolmente le chiamate di disegno e pertanto migliorare le prestazioni.</span><span class="sxs-lookup"><span data-stu-id="5be8d-217">Thus, static batching can be difficult to leverage on HoloLens where virtually every object needs to be placed, moved, scaled, etc. For immersive headsets, static batching can dramatically reduce draw calls and thus improve performance.</span></span>

<span data-ttu-id="5be8d-218">Lettura *batch statici* sotto [disegnare chiamare l'invio in batch in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) per altri dettagli.</span><span class="sxs-lookup"><span data-stu-id="5be8d-218">Read *Static Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for more details.</span></span>

#### <a name="dynamic-batching"></a><span data-ttu-id="5be8d-219">L'invio in batch dinamica</span><span class="sxs-lookup"><span data-stu-id="5be8d-219">Dynamic batching</span></span>

<span data-ttu-id="5be8d-220">Poiché risulta problematico per contrassegnare gli oggetti come *statici* per lo sviluppo di HoloLens, l'invio in batch dinamica può essere uno strumento straordinario per rimediare a questa mancanza di funzionalità.</span><span class="sxs-lookup"><span data-stu-id="5be8d-220">Since it is problematic to mark objects as *Static* for HoloLens development, dynamic batching can be a great tool to compensate for this lacking feature.</span></span> <span data-ttu-id="5be8d-221">Naturalmente, è possibile anche essere utile su anche auricolari coinvolgente e concreto.</span><span class="sxs-lookup"><span data-stu-id="5be8d-221">Of course, it is can also be useful on immersive headsets as well.</span></span> <span data-ttu-id="5be8d-222">In Unity dinamica di invio in batch può essere difficile tuttavia abilitare perché deve Gameobject **a) Condividi lo stesso materiale** e **b) soddisfa un lungo elenco di altri criteri**.</span><span class="sxs-lookup"><span data-stu-id="5be8d-222">Dynamic batching in Unity can be difficult though to enable because GameObjects must **a) share the same Material** and **b) meet a long list of other criteria**.</span></span>

<span data-ttu-id="5be8d-223">Lettura *batch dinamiche* sotto [disegnare chiamare l'invio in batch in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) per un elenco completo.</span><span class="sxs-lookup"><span data-stu-id="5be8d-223">Read *Dynamic Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for the full list.</span></span> <span data-ttu-id="5be8d-224">In genere, Gameobject diventano non validi da inserire in batch in modo dinamico perché i dati di trama associato possono essere vertici non più di 300.</span><span class="sxs-lookup"><span data-stu-id="5be8d-224">Most commonly, GameObjects become invalid to be batched dynamically because the associated mesh data can be no more than 300 vertices.</span></span>

#### <a name="other-techniques"></a><span data-ttu-id="5be8d-225">altre tecniche</span><span class="sxs-lookup"><span data-stu-id="5be8d-225">Other techniques</span></span>

<span data-ttu-id="5be8d-226">L'invio in batch può verificarsi solo se sono in grado di condividere lo stesso materiale Gameobject più.</span><span class="sxs-lookup"><span data-stu-id="5be8d-226">Batching can only occur if multiple GameObjects are able to share the same material.</span></span> <span data-ttu-id="5be8d-227">In genere questo verrà bloccato dalla necessità di disporre di una trama univoca per i rispettivi materiali Gameobject.</span><span class="sxs-lookup"><span data-stu-id="5be8d-227">Typically this will be blocked by the need for GameObjects to have a unique texture for their respective Material.</span></span> <span data-ttu-id="5be8d-228">È comune per combinare le trame in una trama di big data, un metodo noto come [trama Atlasing](https://en.wikipedia.org/wiki/Texture_atlas).</span><span class="sxs-lookup"><span data-stu-id="5be8d-228">It is common to combine Textures into one big Texture, a method known as [Texture Atlasing](https://en.wikipedia.org/wiki/Texture_atlas).</span></span>

<span data-ttu-id="5be8d-229">Inoltre, è in genere preferibile combinare mesh in un GameObject ove possibile e ragionevole.</span><span class="sxs-lookup"><span data-stu-id="5be8d-229">Further, it is generally preferable to combine meshes into one GameObject where possible and reasonable.</span></span> <span data-ttu-id="5be8d-230">Ogni Renderer in Unity avrà sono associate a chiamate di disegno e invio di una rete mesh di combinati in un Renderer.</span><span class="sxs-lookup"><span data-stu-id="5be8d-230">Each Renderer in Unity will have it's associated draw call(s) versus submitting a combined mesh under one Renderer.</span></span> 

>[!NOTE]
> <span data-ttu-id="5be8d-231">Modifica delle proprietà di Renderer.material in fase di esecuzione crea una copia del materiale e pertanto causare il malfunzionamento di invio in batch.</span><span class="sxs-lookup"><span data-stu-id="5be8d-231">Modifying properties of Renderer.material at runtime will create a copy of the Material and thus potentially break batching.</span></span> <span data-ttu-id="5be8d-232">Consente di modificare le proprietà materiale condivise tra Gameobject Renderer.sharedMaterial.</span><span class="sxs-lookup"><span data-stu-id="5be8d-232">Use Renderer.sharedMaterial to modify shared material properties across GameObjects.</span></span>

## <a name="gpu-performance-recommendations"></a><span data-ttu-id="5be8d-233">Raccomandazioni sulle prestazioni di GPU</span><span class="sxs-lookup"><span data-stu-id="5be8d-233">GPU performance recommendations</span></span>

<span data-ttu-id="5be8d-234">Altre informazioni su [ottimizzazione del rendering della grafica in Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span><span class="sxs-lookup"><span data-stu-id="5be8d-234">Learn more about [optimizing graphics rendering in Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span></span> 

### <a name="optimize-depth-buffer-sharing"></a><span data-ttu-id="5be8d-235">Ottimizzare la condivisione del buffer di profondità</span><span class="sxs-lookup"><span data-stu-id="5be8d-235">Optimize depth buffer sharing</span></span>

<span data-ttu-id="5be8d-236">In genere è consigliabile abilitare **condivisione buffer profondità** sotto **Player XR Settings** per ottimizzare le [stabilità ologrammi](Hologram-stability.md).</span><span class="sxs-lookup"><span data-stu-id="5be8d-236">It is generally recommended to enable **Depth buffer sharing** under **Player XR Settings** to optimize for [hologram stability](Hologram-stability.md).</span></span> <span data-ttu-id="5be8d-237">Quando si abilita la profondità in base al ritardo-stage reprojection con questa impostazione, tuttavia, è consigliabile selezionare **formato di 16 bit profondità** invece di **formato a 24 bit profondità**.</span><span class="sxs-lookup"><span data-stu-id="5be8d-237">When enabling depth-based late-stage reprojection with this setting however, it is recommended to select **16-bit depth format** instead of **24-bit depth format**.</span></span> <span data-ttu-id="5be8d-238">La volontà di buffer profondità 16 bit riduce drasticamente la larghezza di banda (e pertanto di alimentazione) associato con il traffico di buffer di profondità.</span><span class="sxs-lookup"><span data-stu-id="5be8d-238">The 16-bit depth buffers will drastically reduces the bandwidth (and thus power) associated with depth buffer traffic.</span></span> <span data-ttu-id="5be8d-239">Ciò può essere un successo di una grande potenza, ma è applicabile solo per esperienze con un intervallo di profondità piccole [z-fighting](https://en.wikipedia.org/wiki/Z-fighting) è più probabile che si verificano con 16 bit rispetto a 24 bit.</span><span class="sxs-lookup"><span data-stu-id="5be8d-239">This can be a big power win, but is only applicable for experiences with a small depth range as [z-fighting](https://en.wikipedia.org/wiki/Z-fighting) is more likely to occur with 16-bit than 24-bit.</span></span> <span data-ttu-id="5be8d-240">Per evitare questi elementi, modificare i piani di ritaglio quasi/anteriore del [fotocamera Unity](https://docs.unity3d.com/Manual/class-Camera.html) a prendere in considerazione la precisione inferiore.</span><span class="sxs-lookup"><span data-stu-id="5be8d-240">To avoid these artifacts, modify the near/far clip planes of the [Unity camera](https://docs.unity3d.com/Manual/class-Camera.html) to account for the lower precision.</span></span> <span data-ttu-id="5be8d-241">Per le applicazioni basate su HoloLens, un piano di ritaglio anteriore di 50 milioni anziché il valore predefinito di Unity 1000M in genere può eliminare qualsiasi z-fighting.</span><span class="sxs-lookup"><span data-stu-id="5be8d-241">For HoloLens-based applications, a far clip plane of 50m instead of the Unity default 1000m can generally eliminate any z-fighting.</span></span>

### <a name="reduce-poly-count"></a><span data-ttu-id="5be8d-242">Ridurre il numero di poligono</span><span class="sxs-lookup"><span data-stu-id="5be8d-242">Reduce poly count</span></span>

<span data-ttu-id="5be8d-243">Numero di poligono in genere viene ridotto di uno</span><span class="sxs-lookup"><span data-stu-id="5be8d-243">Polygon count is usually reduced by either</span></span>
1) <span data-ttu-id="5be8d-244">Rimozione di oggetti in una scena</span><span class="sxs-lookup"><span data-stu-id="5be8d-244">Removing objects from a scene</span></span>
2) <span data-ttu-id="5be8d-245">Decimazione asset che riduce il numero di poligoni per una determinata rete</span><span class="sxs-lookup"><span data-stu-id="5be8d-245">Asset decimation which reduces the number of polygons for a given mesh</span></span>
3) <span data-ttu-id="5be8d-246">Implementazione di un [sistema a livello di dettaglio della TRAMA](https://docs.unity3d.com/Manual/LevelOfDetail.html) nell'applicazione che esegue il rendering a portata di mano gli oggetti con versione inferiore poligono della stessa geometria</span><span class="sxs-lookup"><span data-stu-id="5be8d-246">Implementing a [Level of Detail (LOD) System](https://docs.unity3d.com/Manual/LevelOfDetail.html) into your application which renders far away objects with lower-polygon version of the same geometry</span></span>

### <a name="understanding-shaders-in-unity"></a><span data-ttu-id="5be8d-247">Shader comprensione in Unity</span><span class="sxs-lookup"><span data-stu-id="5be8d-247">Understanding shaders in Unity</span></span>

<span data-ttu-id="5be8d-248">Un'approssimazione semplice per confrontare gli shader nelle prestazioni è per identificare il numero medio di operazioni ogni eseguita in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="5be8d-248">An easy approximation to compare shaders in performance is to identify the average number of operations each executes at runtime.</span></span> <span data-ttu-id="5be8d-249">Questa operazione può essere eseguita facilmente in Unity.</span><span class="sxs-lookup"><span data-stu-id="5be8d-249">This can be done easily in Unity.</span></span>

1) <span data-ttu-id="5be8d-250">Selezionare l'asset shader o selezionare un materiale, quindi nell'angolo superiore destro della finestra del controllo, selezionare l'icona a forma di ingranaggio e quindi **"Selezionare Shader"**</span><span class="sxs-lookup"><span data-stu-id="5be8d-250">Select your shader asset or select a material, then in top right corner of the inspector window, select the gear icon and then **"Select Shader"**</span></span>

    ![Selezionare dello shader in Unity](images/Select-shader-unity.png)
2) <span data-ttu-id="5be8d-252">Con l'asset shader selezionato, scegliere il **"Compilazione e la visualizzazione codice"** pulsante sotto la finestra di controllo</span><span class="sxs-lookup"><span data-stu-id="5be8d-252">With the shader asset selected, click the **"Compile and show code"** button under the inspector window</span></span>

    ![Compilare il codice dello Shader in Unity](images/compile-shader-code-unity.PNG)

3) <span data-ttu-id="5be8d-254">Dopo la compilazione, cercare la sezione relativa alle statistiche nei risultati con il numero di operazioni diverse per pixel e vertex shader (Nota: i pixel shader sono spesso l'acronimo di shader frammento)</span><span class="sxs-lookup"><span data-stu-id="5be8d-254">After compiling, look for the statistics section in the results with the number of different operations for both the vertex and pixel shader (Note: pixel shaders are often also called fragment shaders)</span></span>

    ![Operazioni Standard di Shader di Unity](images/unity-standard-shader-compilation.png)

#### <a name="optmize-pixel-shaders"></a><span data-ttu-id="5be8d-256">Ottimizzazione dei pixel shader</span><span class="sxs-lookup"><span data-stu-id="5be8d-256">Optmize pixel shaders</span></span>

<span data-ttu-id="5be8d-257">Osservando i risultati di statistica compilata usando il metodo precedente, il [frammento shader](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) verranno generalmente eseguite più operazioni rispetto al [shader vertice](https://en.wikipedia.org/wiki/Shader#Vertex_shaders) medio.</span><span class="sxs-lookup"><span data-stu-id="5be8d-257">Looking at the compiled statistic results using the method above, the [fragment shader](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) will generally execute more operations than the [vertex shader](https://en.wikipedia.org/wiki/Shader#Vertex_shaders) on average.</span></span> <span data-ttu-id="5be8d-258">Lo shader frammento, noto anche come il pixel shader, viene eseguito per ogni pixel nella schermata di output del vertex shader viene soltanto eseguito per ogni vertice di tutte le reti da disegnare sullo schermo.</span><span class="sxs-lookup"><span data-stu-id="5be8d-258">The fragment shader, also known as the pixel shader, is executed per pixel on the screen output while the vertex shader is only executed per-vertex of all meshes being drawn to the screen.</span></span> 

<span data-ttu-id="5be8d-259">Di conseguenza, non solo si frammento shader hanno istruzioni maggiore rispetto al vertex shader a causa di tutti i calcoli di illuminazione, gli shader frammento quasi sempre eseguiti in un set di dati più grande.</span><span class="sxs-lookup"><span data-stu-id="5be8d-259">Thus, not only do fragment shaders have more instructions than vertex shaders because of all the lighting calculations, fragment shaders are almost always executed on a larger dataset.</span></span> <span data-ttu-id="5be8d-260">Ad esempio, se l'output dello schermo è una 2K da immagini di 2, quindi lo shader frammento può essere visualizzato eseguita 2, 000 \* 2, 000 = 4,000,000 volte.</span><span class="sxs-lookup"><span data-stu-id="5be8d-260">For example, if the screen output is a 2k by 2k image, then the fragment shader can get executed 2,000\*2,000 = 4,000,000 times.</span></span> <span data-ttu-id="5be8d-261">Se il rendering di entrambi gli occhi, questo numero raddoppia poiché sono presenti due schermate seguenti.</span><span class="sxs-lookup"><span data-stu-id="5be8d-261">If rendering two eyes, this number doubles since there are two screens.</span></span> <span data-ttu-id="5be8d-262">Se un'applicazione di realtà mista dispone di più passaggi, a schermo intero gli effetti di post-elaborazione o rendering più trame per lo stesso pixel, questo numero verrà incrementato in modo significativo.</span><span class="sxs-lookup"><span data-stu-id="5be8d-262">If a mixed reality application has multiple passes, full-screen post-processing effects, or rendering multiple meshes to the same pixel, this number will increase dramatically.</span></span> 

<span data-ttu-id="5be8d-263">Di conseguenza, riducendo il numero di operazioni nello shader frammento può in genere fornire maggiori miglioramenti delle prestazioni tramite ottimizzazioni in vertex shader.</span><span class="sxs-lookup"><span data-stu-id="5be8d-263">Therefore, reducing the number of operations in the fragment shader can generally give far greater performance gains over optimizations in the vertex shader.</span></span>

#### <a name="unity-standard-shader-alternatives"></a><span data-ttu-id="5be8d-264">Alternative Standard shader Unity</span><span class="sxs-lookup"><span data-stu-id="5be8d-264">Unity Standard shader alternatives</span></span>

<span data-ttu-id="5be8d-265">Anziché utilizzare un rendering basato su fisicamente (PBR) o altri shader di alta qualità, osservare che usano un più efficiente e più economica dello shader.</span><span class="sxs-lookup"><span data-stu-id="5be8d-265">Instead of using a physically based rendering (PBR) or other high-quality shader, look at utilizing a more performant and cheaper shader.</span></span> <span data-ttu-id="5be8d-266">Il [Toolkit di realtà mista](https://github.com/Microsoft/MixedRealityToolkit-Unity) fornisce le [shader standard MRTK](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) che è stato ottimizzato per i progetti di realtà mista.</span><span class="sxs-lookup"><span data-stu-id="5be8d-266">The [Mixed Reality Toolkit](https://github.com/Microsoft/MixedRealityToolkit-Unity) provides the [MRTK standard shader](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) that has been optimized for mixed reality projects.</span></span>

<span data-ttu-id="5be8d-267">Unity offre anche un spento, vertice è acceso, le opzioni di shader semplificata con riflessione diffusa e altri che sono significativamente più veloce rispetto a shader Unity Standard.</span><span class="sxs-lookup"><span data-stu-id="5be8d-267">Unity also provides an unlit, vertex lit, diffuse, and other simplified shader options that are significantly faster compared to the Unity Standard shader.</span></span> <span data-ttu-id="5be8d-268">Visualizzare [informazioni sull'utilizzo e prestazioni di shader predefinito](https://docs.unity3d.com/Manual/shader-Performance.html) per informazioni più dettagliate.</span><span class="sxs-lookup"><span data-stu-id="5be8d-268">See [Usage and Performance of Built-in Shaders](https://docs.unity3d.com/Manual/shader-Performance.html) for more detailed information.</span></span>

#### <a name="shader-preloading"></a><span data-ttu-id="5be8d-269">Il precaricamento di shader</span><span class="sxs-lookup"><span data-stu-id="5be8d-269">Shader preloading</span></span>

<span data-ttu-id="5be8d-270">Uso *Shader precaricamento* e altri consigli per ottimizzare [il tempo di caricamento dello shader](http://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span><span class="sxs-lookup"><span data-stu-id="5be8d-270">Use *Shader preloading* and other tricks to optimize [shader load time](http://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span></span> <span data-ttu-id="5be8d-271">In particolare, il precaricamento di shader significa che non verrà visualizzato alcun rallentamenti o interruzioni a causa di compilazione dello shader di runtime.</span><span class="sxs-lookup"><span data-stu-id="5be8d-271">In particular, shader preloading means you won't see any hitches due to runtime shader compilation.</span></span>

### <a name="limit-overdraw"></a><span data-ttu-id="5be8d-272">Limite di caricamento</span><span class="sxs-lookup"><span data-stu-id="5be8d-272">Limit overdraw</span></span>

<span data-ttu-id="5be8d-273">In Unity, uno può visualizzare estenda per le scene, attivando e disattivando il [ **disegnare menu modalità** ](https://docs.unity3d.com/Manual/ViewModes.html) nell'angolo superiore sinistro del **visualizzazione scena** e selezionando **carica presente** .</span><span class="sxs-lookup"><span data-stu-id="5be8d-273">In Unity, one can display overdraw for their scene, by toggling the [**draw mode menu**](https://docs.unity3d.com/Manual/ViewModes.html) in the top left corner of the **Scene view** and selecting **Overdraw**.</span></span>

<span data-ttu-id="5be8d-274">In generale, estenda può essere attenuata della faccia posteriore oggetti anticipo prima che vengano inviati alla GPU.</span><span class="sxs-lookup"><span data-stu-id="5be8d-274">Generally, overdraw can be mitigated by culling objects ahead of time before they are sent to the GPU.</span></span> <span data-ttu-id="5be8d-275">Unity offre informazioni dettagliate sull'implementazione [occlusione della faccia posteriore](https://docs.unity3d.com/Manual/OcclusionCulling.html) per il motore.</span><span class="sxs-lookup"><span data-stu-id="5be8d-275">Unity provides details on implementing [Occlusion Culling](https://docs.unity3d.com/Manual/OcclusionCulling.html) for their engine.</span></span>

## <a name="memory-recommendations"></a><span data-ttu-id="5be8d-276">Consigli sulla memoria</span><span class="sxs-lookup"><span data-stu-id="5be8d-276">Memory recommendations</span></span>

<span data-ttu-id="5be8d-277">Operazioni di allocazione e deallocazione di memoria eccessiva possono avere effetti negativi sull'applicazione holographic causando prestazioni incoerenti, frame bloccati e altri comportamenti dannosi.</span><span class="sxs-lookup"><span data-stu-id="5be8d-277">Excessive memory allocation & deallocation operations can have adverse effects on your holographic application resulting in inconsistent performance, frozen frames, and other detrimental behavior.</span></span> <span data-ttu-id="5be8d-278">È particolarmente importante comprendere considerazioni sulla memoria quando si sviluppa in Unity, poiché la gestione della memoria è controllata dal garbage collector.</span><span class="sxs-lookup"><span data-stu-id="5be8d-278">It is especially important to understand memory considerations when developing in Unity since memory management is controlled by the garbage collector.</span></span>

#### <a name="garbage-collection"></a><span data-ttu-id="5be8d-279">Operazione di Garbage collection</span><span class="sxs-lookup"><span data-stu-id="5be8d-279">Garbage collection</span></span>

<span data-ttu-id="5be8d-280">Le app holographic andranno perse se tempo di calcolo di elaborazione per il garbage collector (GC) quando il Garbage Collector è attivato per analizzare gli oggetti che non sono più nell'ambito durante l'esecuzione e la relativa memoria deve essere rilasciato e può essere reso disponibile per essere riusata.</span><span class="sxs-lookup"><span data-stu-id="5be8d-280">Holographic apps will loose processing compute time to the garbage collector (GC) when the GC is activated to analyze objects that are no longer in scope during execution and their memory needs to be released so it can be made available for re-use.</span></span> <span data-ttu-id="5be8d-281">Deprovisioning e le allocazioni costante richiede in genere il garbage collector eseguire più spesso le prestazioni promuovendo così ed esperienza utente.</span><span class="sxs-lookup"><span data-stu-id="5be8d-281">Constant allocations and de-allocations will generally require the garbage collector to run more frequently thus hurting performance and user experience.</span></span>

<span data-ttu-id="5be8d-282">Unity ha fornito un'eccellente pagina che illustra in dettaglio il funzionamento di garbage collector e suggerimenti per scrivere codice più efficiente in merito alla gestione della memoria.</span><span class="sxs-lookup"><span data-stu-id="5be8d-282">Unity has provided an excellent page that explains in detail how the garbage collector works and tips to write more efficient code in regards to memory management.</span></span>
- [<span data-ttu-id="5be8d-283">Ottimizzazione della procedura di garbage collection in giochi Unity</span><span class="sxs-lookup"><span data-stu-id="5be8d-283">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)

<span data-ttu-id="5be8d-284">Una delle abitudini più comuni che conduce a un numero eccessivo di operazioni di garbage collection non memorizza nella cache i riferimenti a componenti e le classi nello sviluppo di Unity.</span><span class="sxs-lookup"><span data-stu-id="5be8d-284">One of the most common practices that leads to excessive garbage collection is not caching references to components and classes in Unity development.</span></span> <span data-ttu-id="5be8d-285">Tutti i riferimenti devono essere acquisiti durante Start () o Awake() e riusati in funzioni più avanti, ad esempio Update () o LateUpdate().</span><span class="sxs-lookup"><span data-stu-id="5be8d-285">Any references should be captured during Start() or Awake() and re-used in later functions such as Update() or LateUpdate().</span></span>

<span data-ttu-id="5be8d-286">Altri suggerimenti rapidi:</span><span class="sxs-lookup"><span data-stu-id="5be8d-286">Other quick tips:</span></span>
- <span data-ttu-id="5be8d-287">Usare la [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) C# classe per la creazione in modo dinamico le stringhe complesse in fase di esecuzione</span><span class="sxs-lookup"><span data-stu-id="5be8d-287">Use the [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) C# class to dynamically build complex strings at runtime</span></span>
- <span data-ttu-id="5be8d-288">Rimuovere le chiamate a Debug.Log() quando non servono più mentre vengono ancora eseguite in tutte le versioni di compilazione di un'app</span><span class="sxs-lookup"><span data-stu-id="5be8d-288">Remove calls to Debug.Log() when no longer needed as they still execute in all build versions of an app</span></span>
- <span data-ttu-id="5be8d-289">Se l'app holographic richiede in genere grandi quantità di memoria, si consiglia di chiamare [ _**System.GC.Collect ()**_ ](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) durante il caricamento di fasi, ad esempio per la presentazione di un caricamento o schermata di transizione</span><span class="sxs-lookup"><span data-stu-id="5be8d-289">If your holographic app generally requires lots of memory, consider calling  [_**System.GC.Collect()**_](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) during loading phases such as when presenting a loading or transition screen</span></span>

#### <a name="object-pooling"></a><span data-ttu-id="5be8d-290">Pool di oggetti</span><span class="sxs-lookup"><span data-stu-id="5be8d-290">Object pooling</span></span>

<span data-ttu-id="5be8d-291">Il pool degli oggetti è una tecnica comune per ridurre il costo delle allocazioni di continuo e le deallocazioni di oggetti.</span><span class="sxs-lookup"><span data-stu-id="5be8d-291">Object pooling is a popular technique to reduce the cost of continuous allocations & deallocations of objects.</span></span> <span data-ttu-id="5be8d-292">Questa operazione viene eseguita, allocando un ampio pool di oggetti identici e riutilizzo di istanze inattive, disponibile da questo pool anziché continuamente durante la generazione e l'eliminazione definitiva di oggetti nel corso del tempo.</span><span class="sxs-lookup"><span data-stu-id="5be8d-292">This is done by allocating a large pool of identical objects and re-using inactive, available instances from this pool instead of constantly spawning and destroying objects over time.</span></span> <span data-ttu-id="5be8d-293">Pool di oggetti sono ideali per i componenti riutilizzabili che includono la durata delle variabili durante un'app.</span><span class="sxs-lookup"><span data-stu-id="5be8d-293">Object pools are great for re-useable components that have variable lifetime during an app.</span></span>

- [<span data-ttu-id="5be8d-294">Esercitazione di Unity di pool di oggetti</span><span class="sxs-lookup"><span data-stu-id="5be8d-294">Object Pooling Tutorial in Unity</span></span>](https://unity3d.com/learn/tutorials/topics/scripting/object-pooling) 

## <a name="startup-performance"></a><span data-ttu-id="5be8d-295">Prestazioni di avvio</span><span class="sxs-lookup"><span data-stu-id="5be8d-295">Startup performance</span></span>

<span data-ttu-id="5be8d-296">Avviare l'app con una scena più piccola, quindi l'uso, è necessario considerare *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* per caricare il resto della scena.</span><span class="sxs-lookup"><span data-stu-id="5be8d-296">You should consider starting your app with a smaller scene, then using *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* to load the rest of the scene.</span></span> <span data-ttu-id="5be8d-297">Ciò consente all'app di ottenere lo stato interattivo nel minor tempo.</span><span class="sxs-lookup"><span data-stu-id="5be8d-297">This allows your app to get to an interactive state as fast as possible.</span></span> <span data-ttu-id="5be8d-298">Essere consapevoli che possono essere presenti uno spike elevato della CPU mentre viene attivata la nuova scena e che qualsiasi contenuto sottoposto a rendering potrebbe stuttering o nessuna difficoltà.</span><span class="sxs-lookup"><span data-stu-id="5be8d-298">Be aware that there may be a large CPU spike while the new scene is being activated and that any rendered content might stutter or hitch.</span></span> <span data-ttu-id="5be8d-299">Uno per risolvere questo problema consiste nell'impostare la proprietà AsyncOperation.allowSceneActivation su false nella scena in fase di caricamento, attendere la scena caricare, cancellare lo schermo nero e quindi reimpostato su true per completare l'attivazione di scena.</span><span class="sxs-lookup"><span data-stu-id="5be8d-299">One way to work around this is to set the AsyncOperation.allowSceneActivation property to false on the scene being loaded, wait for the scene to load, clear the screen to black, and then set back to true to complete the scene activation.</span></span>

<span data-ttu-id="5be8d-300">Tenere presente che mentre la scena di avvio viene caricata la schermata iniziale holographic verrà visualizzata all'utente.</span><span class="sxs-lookup"><span data-stu-id="5be8d-300">Remember that while the startup scene is loading the holographic splash screen will be displayed to the user.</span></span>

## <a name="see-also"></a><span data-ttu-id="5be8d-301">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="5be8d-301">See also</span></span>
- [<span data-ttu-id="5be8d-302">Ottimizzazione del rendering di grafica in giochi Unity</span><span class="sxs-lookup"><span data-stu-id="5be8d-302">Optimizing graphics rendering in Unity games</span></span>](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games?playlist=44069)
- [<span data-ttu-id="5be8d-303">Ottimizzazione della procedura di garbage collection in giochi Unity</span><span class="sxs-lookup"><span data-stu-id="5be8d-303">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)
- <span data-ttu-id="5be8d-304">[Procedure consigliate di fisica [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span><span class="sxs-lookup"><span data-stu-id="5be8d-304">[Physics Best Practices [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span></span>
- <span data-ttu-id="5be8d-305">[Ottimizzazione degli script [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span><span class="sxs-lookup"><span data-stu-id="5be8d-305">[Optimizing Scripts [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span></span>
