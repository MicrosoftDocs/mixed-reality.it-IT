---
title: Suggerimenti sulle prestazioni per Unity
description: Suggerimenti specifici per Unity per migliorare le prestazioni con le app di realtà mista.
author: Troy-Ferrell
ms.author: trferrel
ms.date: 03/26/2019
ms.topic: article
keywords: grafica, CPU, GPU, rendering, Garbage Collection, hololens
ms.openlocfilehash: f3fdda94c417d9f8e8980a90e8928282789e3d0f
ms.sourcegitcommit: 2cf3f19146d6a7ba71bbc4697a59064b4822b539
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 11/12/2019
ms.locfileid: "73926865"
---
# <a name="performance-recommendations-for-unity"></a><span data-ttu-id="68b37-104">Suggerimenti sulle prestazioni per Unity</span><span class="sxs-lookup"><span data-stu-id="68b37-104">Performance recommendations for Unity</span></span>

<span data-ttu-id="68b37-105">Questo articolo si basa sulla discussione descritta in [raccomandazioni sulle prestazioni per la realtà mista](understanding-performance-for-mixed-reality.md) , ma è incentrata sulle informazioni specifiche dell'ambiente del motore Unity.</span><span class="sxs-lookup"><span data-stu-id="68b37-105">This article builds on the discussion outlined in [performance recommendations for mixed reality](understanding-performance-for-mixed-reality.md) but focuses on learnings specific to the Unity engine environment.</span></span>

<span data-ttu-id="68b37-106">È inoltre consigliabile che gli sviluppatori rivedano le [impostazioni di ambiente consigliate per l'articolo di Unity](Recommended-settings-for-unity.md).</span><span class="sxs-lookup"><span data-stu-id="68b37-106">It is also highly advisable that developers review the [recommended environment settings for Unity article](Recommended-settings-for-unity.md).</span></span> <span data-ttu-id="68b37-107">Questo articolo presenta contenuti con alcune delle configurazioni di scena più importanti in relazione alla creazione di app per realtà mista a prestazioni elevate.</span><span class="sxs-lookup"><span data-stu-id="68b37-107">This article has content with some of the most important scene configurations in regards to building performant Mixed Reality apps.</span></span> <span data-ttu-id="68b37-108">Alcune di queste impostazioni consigliate sono evidenziate anche di seguito.</span><span class="sxs-lookup"><span data-stu-id="68b37-108">Some of these recommended settings are highlighted below as well.</span></span>

## <a name="how-to-profile-with-unity"></a><span data-ttu-id="68b37-109">Come eseguire la profilatura con Unity</span><span class="sxs-lookup"><span data-stu-id="68b37-109">How to profile with Unity</span></span>

<span data-ttu-id="68b37-110">Unity offre il **[Profiler di Unity](https://docs.unity3d.com/Manual/Profiler.html)** , che è un'ottima risorsa per raccogliere informazioni preziose sulle prestazioni per la tua app specifica.</span><span class="sxs-lookup"><span data-stu-id="68b37-110">Unity provides the **[Unity Profiler](https://docs.unity3d.com/Manual/Profiler.html)** built-in which is a great resource to gather valuable performance insights for your particular app.</span></span> <span data-ttu-id="68b37-111">Sebbene sia possibile eseguire il profiler in-Editor, queste metriche non rappresentano l'ambiente di runtime reale e, di conseguenza, i risultati di questa operazione devono essere usati con cautela.</span><span class="sxs-lookup"><span data-stu-id="68b37-111">Although one can run the profiler in-editor, these metrics do not represent the true runtime environment and thus, results from this should be used cautiously.</span></span> <span data-ttu-id="68b37-112">È consigliabile profilare l'applicazione in modalità remota mentre è in esecuzione nel dispositivo per ottenere informazioni più accurate e di utilità pratica.</span><span class="sxs-lookup"><span data-stu-id="68b37-112">It is recommended to remotely profile your application while running on device for most accurate and actionable insights.</span></span> <span data-ttu-id="68b37-113">Inoltre, il [debugger frame](https://docs.unity3d.com/Manual/FrameDebugger.html) di Unity è anche uno strumento molto potente e Insight da usare.</span><span class="sxs-lookup"><span data-stu-id="68b37-113">Further, Unity's [Frame Debugger](https://docs.unity3d.com/Manual/FrameDebugger.html)  is also a very powerful and insight tool to utilize.</span></span>

<span data-ttu-id="68b37-114">Unity offre la documentazione ideale per:</span><span class="sxs-lookup"><span data-stu-id="68b37-114">Unity provides great documentation for:</span></span>
1) <span data-ttu-id="68b37-115">Come connettere [Unity Profiler alle applicazioni UWP in remoto](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span><span class="sxs-lookup"><span data-stu-id="68b37-115">How to connect the [Unity profiler to UWP applications remotely](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span></span>
2) <span data-ttu-id="68b37-116">Come diagnosticare in modo efficace [i problemi di prestazioni con Unity Profiler](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span><span class="sxs-lookup"><span data-stu-id="68b37-116">How to effectively [diagnose performance problems with the Unity Profiler](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span></span>

>[!NOTE]
> <span data-ttu-id="68b37-117">Con il profiler di Unity connesso e dopo l'aggiunta del profiler della GPU (vedere *aggiungere Profiler* nell'angolo superiore destro), è possibile visualizzare il tempo dedicato alla CPU & GPU rispettivamente al centro del profiler.</span><span class="sxs-lookup"><span data-stu-id="68b37-117">With the Unity Profiler connected and after adding the GPU profiler (see *Add Profiler* in top right corner), one can see how much time is being spent on the CPU & GPU respectively in the middle of the profiler.</span></span> <span data-ttu-id="68b37-118">Ciò consente allo sviluppatore di ottenere una rapida approssimazione se l'applicazione è associata a CPU o GPU.</span><span class="sxs-lookup"><span data-stu-id="68b37-118">This allows the developer to get a quick approximation if their application is CPU or GPU bounded.</span></span>
>
> ![CPU Unity rispetto alla GPU](images/unity-profiler-cpu-gpu.png)

## <a name="cpu-performance-recommendations"></a><span data-ttu-id="68b37-120">Raccomandazioni sulle prestazioni della CPU</span><span class="sxs-lookup"><span data-stu-id="68b37-120">CPU performance recommendations</span></span>

<span data-ttu-id="68b37-121">Il contenuto riportato di seguito include procedure di prestazioni più approfondite, specialmente destinate C# a unity & Development.</span><span class="sxs-lookup"><span data-stu-id="68b37-121">The content below covers more in-depth performance practices, especially targeted for Unity & C# development.</span></span>

#### <a name="cache-references"></a><span data-ttu-id="68b37-122">Riferimenti alla cache</span><span class="sxs-lookup"><span data-stu-id="68b37-122">Cache references</span></span>

<span data-ttu-id="68b37-123">È consigliabile memorizzare nella cache i riferimenti a tutti i componenti rilevanti e GameObject in fase di inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="68b37-123">It is best practice to cache references to all relevant components and GameObjects at initialization.</span></span> <span data-ttu-id="68b37-124">Ciò è dovuto al fatto che le chiamate di funzione ripetute come *[getComponent\<t > ()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* sono molto più dispendiose rispetto al costo di memoria per l'archiviazione di un puntatore.</span><span class="sxs-lookup"><span data-stu-id="68b37-124">This is because repeating function calls such as *[GetComponent\<T>()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* are significantly more expensive relative to the memory cost to store a pointer.</span></span> <span data-ttu-id="68b37-125">Questo vale anche per la [fotocamera. Main](https://docs.unity3d.com/ScriptReference/Camera-main.html)utilizzata regolarmente.</span><span class="sxs-lookup"><span data-stu-id="68b37-125">This also applies to to the very, regularly used [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html).</span></span> <span data-ttu-id="68b37-126">La *fotocamera. Main* in realtà usa solo *[FindGameObjectsWithTag ()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* sotto il quale cerca in modo oneroso il grafico della scena per un oggetto della fotocamera con il tag *"MainCamera"* .</span><span class="sxs-lookup"><span data-stu-id="68b37-126">*Camera.main* actually just uses *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* underneath which expensively searches your scene graph for a camera object with the *"MainCamera"* tag.</span></span>

```CS
using UnityEngine;
using System.Collections;

public class ExampleClass : MonoBehaviour
{
    private Camera cam;
    private CustomComponent comp;

    void Start() 
    {
        cam = Camera.main;
        comp = GetComponent<CustomComponent>();
    }

    void Update()
    {
        // Good
        this.transform.position = cam.transform.position + cam.transform.forward * 10.0f;

        // Bad
        this.transform.position = Camera.main.transform.position + Camera.main.transform.forward * 10.0f;

        // Good
        comp.DoSomethingAwesome();

        // Bad
        GetComponent<CustomComponent>().DoSomethingAwesome();
    }
}
```

>[!NOTE] 
> <span data-ttu-id="68b37-127">Evitare GetComponent (String)</span><span class="sxs-lookup"><span data-stu-id="68b37-127">Avoid GetComponent(string)</span></span> <br/>
> <span data-ttu-id="68b37-128">Quando si utilizza *[GetComponent ()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* , sono presenti alcuni overload diversi.</span><span class="sxs-lookup"><span data-stu-id="68b37-128">When using *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)*, there are a handful of different overloads.</span></span> <span data-ttu-id="68b37-129">È importante usare sempre le implementazioni basate sui tipi e mai l'overload di ricerca basato su stringa.</span><span class="sxs-lookup"><span data-stu-id="68b37-129">It is important to always use the Type based implementations and never the string-based searching overload.</span></span> <span data-ttu-id="68b37-130">La ricerca per stringa nella scena è notevolmente più costosa rispetto alla ricerca per tipo.</span><span class="sxs-lookup"><span data-stu-id="68b37-130">Searching by string in your scene is significantly more costly than searching by Type.</span></span> <br/>
> <span data-ttu-id="68b37-131">Buona Componente GetComponent (tipo Type)</span><span class="sxs-lookup"><span data-stu-id="68b37-131">(Good) Component GetComponent(Type type)</span></span> <br/>
> <span data-ttu-id="68b37-132">Buona T getComponent\<T > ()</span><span class="sxs-lookup"><span data-stu-id="68b37-132">(Good) T GetComponent\<T>()</span></span> <br/>
> <span data-ttu-id="68b37-133">Non valido Componente GetComponent (String) ></span><span class="sxs-lookup"><span data-stu-id="68b37-133">(Bad) Component GetComponent(string)></span></span> <br/>

#### <a name="avoid-expensive-operations"></a><span data-ttu-id="68b37-134">Evitare operazioni costose</span><span class="sxs-lookup"><span data-stu-id="68b37-134">Avoid expensive operations</span></span>

1) <span data-ttu-id="68b37-135">**Evitare l'utilizzo di [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span><span class="sxs-lookup"><span data-stu-id="68b37-135">**Avoid use of [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span></span>

    <span data-ttu-id="68b37-136">Sebbene LINQ possa essere molto pulito e facile da leggere e scrivere, in genere richiede un maggior numero di calcoli e una maggiore allocazione di memoria rispetto alla scrittura manuale dell'algoritmo.</span><span class="sxs-lookup"><span data-stu-id="68b37-136">Although LINQ can be very clean and easy to read and write, it generally requires much more computation and particularly more memory allocation than writing the algorithm out manually.</span></span>

    ```CS
    // Example Code
    using System.Linq;

    List<int> data = new List<int>();
    data.Any(x => x > 10);

    var result = from x in data
                 where x > 10
                 select x;
    ```

2) <span data-ttu-id="68b37-137">**API Unity comuni**</span><span class="sxs-lookup"><span data-stu-id="68b37-137">**Common Unity APIs**</span></span>

    <span data-ttu-id="68b37-138">Alcune API Unity, sebbene utili, possono essere molto costose da eseguire.</span><span class="sxs-lookup"><span data-stu-id="68b37-138">Certain Unity APIs, although useful, can be very expensive to execute.</span></span> <span data-ttu-id="68b37-139">La maggior parte di questi comportano la ricerca dell'intero grafico della scena per un elenco corrispondente di GameObject.</span><span class="sxs-lookup"><span data-stu-id="68b37-139">Most of these involve searching your entire scene graph for some matching list of GameObjects.</span></span> <span data-ttu-id="68b37-140">Queste operazioni possono in genere essere evitate memorizzando nella cache i riferimenti o implementando un componente di gestione per GameObject in questione per tenere traccia dei riferimenti in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="68b37-140">These operations can generally be avoided by caching references or implementing a manager component for the GameObjects in question to track the references at runtime.</span></span>

        GameObject.SendMessage()
        GameObject.BroadcastMessage()
        UnityEngine.Object.Find()
        UnityEngine.Object.FindWithTag()
        UnityEngine.Object.FindObjectOfType()
        UnityEngine.Object.FindObjectsOfType()
        UnityEngine.Object.FindGameObjectsWithTag()
        UnityEngine.Object.FindGameObjectsWithTag()

>[!NOTE]
> <span data-ttu-id="68b37-141">*[SendMessage ()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* e *[BroadcastMessage ()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* devono essere eliminati a tutti i costi.</span><span class="sxs-lookup"><span data-stu-id="68b37-141">*[SendMessage()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* and *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* should be eliminated at all costs.</span></span> <span data-ttu-id="68b37-142">Queste funzioni possono essere in ordine di 1.000 volte più lento rispetto alle chiamate di funzione dirette.</span><span class="sxs-lookup"><span data-stu-id="68b37-142">These functions can be on the order of 1000x slower than direct function calls.</span></span>

3) <span data-ttu-id="68b37-143">**Attenzione alla conversione boxing**</span><span class="sxs-lookup"><span data-stu-id="68b37-143">**Beware of boxing**</span></span>

    <span data-ttu-id="68b37-144">La C# [conversione boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) è un concetto di base del linguaggio e del runtime.</span><span class="sxs-lookup"><span data-stu-id="68b37-144">[Boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) is a core concept of the C# language and runtime.</span></span> <span data-ttu-id="68b37-145">Si tratta del processo di wrapping di variabili tipizzate a valore quali Char, int, bool e così via in variabili tipizzate a cui si fa riferimento.</span><span class="sxs-lookup"><span data-stu-id="68b37-145">It is the process of wrapping value-typed variables such as char, int, bool, etc. into reference-typed variables.</span></span> <span data-ttu-id="68b37-146">Quando una variabile tipizzata come valore è "boxed", viene sottoposta a incapsulamento all'interno di un oggetto System. Object archiviato nell'heap gestito.</span><span class="sxs-lookup"><span data-stu-id="68b37-146">When a value-typed variable is "boxed", it is wrapped inside of a System.Object which is stored on the managed heap.</span></span> <span data-ttu-id="68b37-147">In questo modo, la memoria viene allocata e alla fine, quando eliminata, deve essere elaborata dal Garbage Collector.</span><span class="sxs-lookup"><span data-stu-id="68b37-147">Thus, memory is allocated and eventually when disposed must be processed by the garbage collector.</span></span> <span data-ttu-id="68b37-148">Queste allocazioni e deallocazioni comportano un costo in termini di prestazioni e in molti scenari non sono necessari o possono essere facilmente sostituiti da un'alternativa meno costosa.</span><span class="sxs-lookup"><span data-stu-id="68b37-148">These allocations and deallocations incur a performance cost and in many scenarios are unnecessary or can be easily replaced by a less expensive alternative.</span></span>

    <span data-ttu-id="68b37-149">Una delle forme più comuni di conversione boxing nello sviluppo è l'uso di [tipi di valore Nullable](https://docs.microsoft.com//dotnet/csharp/programming-guide/nullable-types/).</span><span class="sxs-lookup"><span data-stu-id="68b37-149">One of the most common forms of boxing in development is the use of [nullable value types](https://docs.microsoft.com//dotnet/csharp/programming-guide/nullable-types/).</span></span> <span data-ttu-id="68b37-150">È normale che si voglia essere in grado di restituire null per un tipo di valore in una funzione, specialmente quando l'operazione potrebbe non riuscire a ottenere il valore.</span><span class="sxs-lookup"><span data-stu-id="68b37-150">It is common to want to be able to return null for a value type in a function especially when the operation may fail trying to get the value.</span></span> <span data-ttu-id="68b37-151">Il potenziale problema con questo approccio è che l'allocazione è ora presente nell'heap e, di conseguenza, deve essere sottoposta a Garbage Collection in seguito.</span><span class="sxs-lookup"><span data-stu-id="68b37-151">The potential problem with this approach is that allocation now occur on the heap and consequently need to be garbage collected later.</span></span>

    <span data-ttu-id="68b37-152">**Esempio di conversione boxing inC#**</span><span class="sxs-lookup"><span data-stu-id="68b37-152">**Example of boxing in C#**</span></span>

    ```csharp
    // boolean value type is boxed into object boxedMyVar on the heap
    bool myVar = true;
    object boxedMyVar = myVar;
    ```

    <span data-ttu-id="68b37-153">**Esempio di conversione boxing problematica tramite tipi di valore Nullable**</span><span class="sxs-lookup"><span data-stu-id="68b37-153">**Example of problematic boxing via nullable value types**</span></span>

    <span data-ttu-id="68b37-154">Questo codice illustra una classe particella fittizia che è possibile creare in un progetto Unity.</span><span class="sxs-lookup"><span data-stu-id="68b37-154">This code demonstrates a dummy particle class that one may create in a Unity project.</span></span> <span data-ttu-id="68b37-155">Una chiamata a `TryGetSpeed()` provocherà l'allocazione di oggetti nell'heap che dovrà essere sottoposta a Garbage Collection in un secondo momento.</span><span class="sxs-lookup"><span data-stu-id="68b37-155">A call to `TryGetSpeed()` will cause object allocation on the heap which will need to be garbage collected at a later point in time.</span></span> <span data-ttu-id="68b37-156">Questo esempio è particolarmente problematico perché in una scena possono essere presenti oltre 1000 particelle, ciascuna delle quali viene richiesta la velocità corrente.</span><span class="sxs-lookup"><span data-stu-id="68b37-156">This example is particularly problematic as there may be 1000+ or many more particles in a scene, each being asked for their current speed.</span></span> <span data-ttu-id="68b37-157">In questo modo, vengono allocati 1.000 oggetti e, di conseguenza, deallocati tutti i frame che diminuiscono notevolmente le prestazioni.</span><span class="sxs-lookup"><span data-stu-id="68b37-157">Thus, 1000's of objects would be allocated and consequently de-allocated every frame which would greatly diminish performance.</span></span> <span data-ttu-id="68b37-158">La riscrittura della funzione per la restituzione di un valore negativo, ad esempio-1, per indicare un errore evita questo problema e mantiene la memoria nello stack.</span><span class="sxs-lookup"><span data-stu-id="68b37-158">Re-writing the function to return a negative value such as -1 to indicate a failure would avoid this issue and keep memory on the stack.</span></span>

    ```csharp
        public class MyParticle
        {
            // Example of function returning nullable value type
            public int? TryGetSpeed()
            {
                // Returns current speed int value or null if fails
            }
        }
    ```

#### <a name="repeating-code-paths"></a><span data-ttu-id="68b37-159">Ripetizione dei percorsi di codice</span><span class="sxs-lookup"><span data-stu-id="68b37-159">Repeating code paths</span></span>

<span data-ttu-id="68b37-160">Tutte le funzioni di callback Unity ripetute (ad esempio</span><span class="sxs-lookup"><span data-stu-id="68b37-160">Any repeating Unity callback functions (i.e</span></span> <span data-ttu-id="68b37-161">Update) che vengono eseguiti più volte al secondo e/o frame devono essere scritti con molta attenzione.</span><span class="sxs-lookup"><span data-stu-id="68b37-161">Update) that are executed many times per second and/or frame should be written very carefully.</span></span> <span data-ttu-id="68b37-162">Tutte le operazioni dispendiose in questo caso avranno un notevole effetto sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="68b37-162">Any expensive operations here will have huge and consistent impact on performance.</span></span>

1) <span data-ttu-id="68b37-163">**Funzioni di callback vuote**</span><span class="sxs-lookup"><span data-stu-id="68b37-163">**Empty callback functions**</span></span>

    <span data-ttu-id="68b37-164">Sebbene il codice seguente possa sembrare innocente da lasciare nell'applicazione, soprattutto perché ogni script Unity Inizializza automaticamente con questo blocco di codice, queste richiamate vuote possono effettivamente diventare molto costose.</span><span class="sxs-lookup"><span data-stu-id="68b37-164">Although the code below may seem innocent to leave in your application, especially since every Unity script auto-initializes with this code block, these empty callbacks can actually become very expensive.</span></span> <span data-ttu-id="68b37-165">Unity opera avanti e indietro su un limite di codice gestito/non gestito, tra il codice UnityEngine e il codice dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="68b37-165">Unity operates back and forth over an unmanaged/managed code boundary, between UnityEngine code and your application code.</span></span> <span data-ttu-id="68b37-166">Il cambio di contesto di questo Bridge è piuttosto costoso anche se non è necessario eseguire alcuna operazione.</span><span class="sxs-lookup"><span data-stu-id="68b37-166">Context switching over this bridge is fairly expensive even if there is nothing to execute.</span></span> <span data-ttu-id="68b37-167">Questa operazione diventa particolarmente problematica se l'app dispone di 100 GameObject con componenti con callback di Unity ripetuti vuoti.</span><span class="sxs-lookup"><span data-stu-id="68b37-167">This becomes especially problematic if your app has 100's of GameObjects with components that have empty repeating Unity callbacks.</span></span>

    ```CS
    void Update()
    {
    }
    ```

>[!NOTE]
> <span data-ttu-id="68b37-168">Update () è la manifestazione più comune di questo problema di prestazioni, ma gli altri callback di Unity ripetuti come quelli riportati di seguito possono essere ugualmente non validi se non peggiori: FixedUpdate (), LateUpdate (), OnPostRender ", OnPreRender (), OnRenderImage () e così via.</span><span class="sxs-lookup"><span data-stu-id="68b37-168">Update() is the most common manifestation of this performance issue but other repeating Unity callbacks such as the following can be equally as bad if not worse: FixedUpdate(), LateUpdate(), OnPostRender", OnPreRender(), OnRenderImage(), etc.</span></span> 

2) <span data-ttu-id="68b37-169">**Operazioni che favoriscono l'esecuzione una volta per ogni fotogramma**</span><span class="sxs-lookup"><span data-stu-id="68b37-169">**Operations to favor running once per frame**</span></span>

    <span data-ttu-id="68b37-170">Le seguenti API Unity sono operazioni comuni per molte app olografiche.</span><span class="sxs-lookup"><span data-stu-id="68b37-170">The following Unity APIs are common operations for many Holographic Apps.</span></span> <span data-ttu-id="68b37-171">Sebbene non sia sempre possibile, i risultati di queste funzioni possono essere calcolati in genere una sola volta e i risultati vengono riutilizzati nell'applicazione per un determinato frame.</span><span class="sxs-lookup"><span data-stu-id="68b37-171">Although not always possible, the results from these functions can very commonly be computed once and the results re-utilized across the application for a given frame.</span></span>

    <span data-ttu-id="68b37-172">a) in genere è consigliabile avere un servizio o una classe singleton dedicata per gestire lo sguardo Raycast nella scena e quindi riutilizzare questo risultato in tutti gli altri componenti della scena, anziché eseguire operazioni Raycast ripetute e essenzialmente identiche da ogni componente.</span><span class="sxs-lookup"><span data-stu-id="68b37-172">a) Generally it is good practice to have a dedicated Singleton class or service to handle your gaze Raycast into the scene and then re-use this result in all other scene components, instead of making repeated and essentially identical Raycast operations by each component.</span></span> <span data-ttu-id="68b37-173">Naturalmente, alcune applicazioni possono richiedere raycasts da origini diverse o da [LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html)diversi.</span><span class="sxs-lookup"><span data-stu-id="68b37-173">Of course, some applications may require raycasts from different origins or against different [LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span></span>

        UnityEngine.Physics.Raycast()
        UnityEngine.Physics.RaycastAll()

    <span data-ttu-id="68b37-174">b) evitare operazioni GetComponent () in richiamate Unity ripetute come Update () [memorizzando nella cache i riferimenti](#cache-references) in Start () o svegli ()</span><span class="sxs-lookup"><span data-stu-id="68b37-174">b) Avoid GetComponent() operations in repeated Unity callbacks like Update() by [caching references](#cache-references) in Start() or Awake()</span></span>

        UnityEngine.Object.GetComponent()

    <span data-ttu-id="68b37-175">c) è consigliabile creare un'istanza di tutti gli oggetti, se possibile, in fase di inizializzazione e usare il [pool di oggetti](#object-pooling) per riciclare e riutilizzare GameObject durante il runtime dell'applicazione</span><span class="sxs-lookup"><span data-stu-id="68b37-175">c) It is good practice to instantiate all objects, if possible, at initialization and use [object pooling](#object-pooling) to recycle and re-use GameObjects throughout runtime of your application</span></span>

        UnityEngine.Object.Instantiate()

3) <span data-ttu-id="68b37-176">**Evitare le interfacce e i costrutti virtuali**</span><span class="sxs-lookup"><span data-stu-id="68b37-176">**Avoid interfaces and virtual constructs**</span></span>

    <span data-ttu-id="68b37-177">Richiamando le chiamate di funzione tramite le interfacce e gli oggetti diretti oppure chiamando le funzioni virtuali spesso è molto più costoso rispetto all'uso di costrutti diretti o chiamate di funzioni dirette.</span><span class="sxs-lookup"><span data-stu-id="68b37-177">Invoking function calls through interfaces vs direct objects or calling virtual functions can often times be much more expensive than utilizing direct constructs or direct function calls.</span></span> <span data-ttu-id="68b37-178">Se la funzione o l'interfaccia virtuale non è necessaria, è necessario rimuoverla.</span><span class="sxs-lookup"><span data-stu-id="68b37-178">If the virtual function or interface is unnecessary, then it should be removed.</span></span> <span data-ttu-id="68b37-179">Tuttavia, l'impatto sulle prestazioni di questi approcci è in genere degno di compromesso se l'uso semplifica la collaborazione di sviluppo, la leggibilità del codice e la gestibilità del codice.</span><span class="sxs-lookup"><span data-stu-id="68b37-179">However, the performance hit for these approaches are generally worth the trade-off if utilizing them simplifies development collaboration, code readability, and code maintainability.</span></span>

    <span data-ttu-id="68b37-180">In genere, è consigliabile non contrassegnare campi e funzioni come virtuali, a meno che non esista una chiara previsione che questo membro debba essere sovrascritto.</span><span class="sxs-lookup"><span data-stu-id="68b37-180">Generally, the recommendation is to not mark fields and functions as virtual unless there is a clear expectation that this member needs to be overwritten.</span></span> <span data-ttu-id="68b37-181">È necessario prestare particolare attenzione ai percorsi di codice ad alta frequenza che vengono chiamati più volte per fotogramma o anche una volta per fotogramma, ad esempio un metodo di `UpdateUI()`.</span><span class="sxs-lookup"><span data-stu-id="68b37-181">One should be especially careful around high-frequency code paths that are called many times per frame or even once per frame such as an `UpdateUI()` method.</span></span>

4) <span data-ttu-id="68b37-182">**Evitare il passaggio di struct in base al valore**</span><span class="sxs-lookup"><span data-stu-id="68b37-182">**Avoid passing structs by value**</span></span>

    <span data-ttu-id="68b37-183">Diversamente dalle classi, gli struct sono tipi di valore e, quando vengono passati direttamente a una funzione, il relativo contenuto viene copiato in un'istanza appena creata.</span><span class="sxs-lookup"><span data-stu-id="68b37-183">Unlike classes, structs are value-types and when passed directly to a function, their contents are copied into a newly created instance.</span></span> <span data-ttu-id="68b37-184">Questa copia aggiunge costi CPU e memoria aggiuntiva nello stack.</span><span class="sxs-lookup"><span data-stu-id="68b37-184">This copy adds CPU cost as well as additional memory on the stack.</span></span> <span data-ttu-id="68b37-185">Per gli struct di piccole dimensioni, l'effetto è generalmente minimo e quindi accettabile.</span><span class="sxs-lookup"><span data-stu-id="68b37-185">For small structs, the effect is usually very minimal and thus acceptable.</span></span> <span data-ttu-id="68b37-186">Tuttavia, per le funzioni richiamate ripetutamente ogni frame e funzioni che accettano struct di grandi dimensioni, se possibile, modificare la definizione della funzione in modo che venga passata per riferimento.</span><span class="sxs-lookup"><span data-stu-id="68b37-186">However, for functions repeatedly invoked every frame as well as functions taking large structs, if possible modify the function definition to pass by reference.</span></span> [<span data-ttu-id="68b37-187">Altre informazioni sono disponibili qui</span><span class="sxs-lookup"><span data-stu-id="68b37-187">Learn more here</span></span>](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/how-to-know-the-difference-passing-a-struct-and-passing-a-class-to-a-method)

#### <a name="miscellaneous"></a><span data-ttu-id="68b37-188">Varie</span><span class="sxs-lookup"><span data-stu-id="68b37-188">Miscellaneous</span></span>

1) <span data-ttu-id="68b37-189">**Fisica**</span><span class="sxs-lookup"><span data-stu-id="68b37-189">**Physics**</span></span>

    <span data-ttu-id="68b37-190">a) generalmente, il modo più semplice per migliorare la fisica consiste nel limitare la quantità di tempo impiegato per la fisica o il numero di iterazioni al secondo.</span><span class="sxs-lookup"><span data-stu-id="68b37-190">a) Generally, easiest way to improve physics is to limit the amount of time spent on Physics or the number of iterations per second.</span></span> <span data-ttu-id="68b37-191">Naturalmente, questa operazione ridurrà la precisione della simulazione.</span><span class="sxs-lookup"><span data-stu-id="68b37-191">Of course, this will reduce simulation accuracy.</span></span> <span data-ttu-id="68b37-192">Vedere [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) in Unity</span><span class="sxs-lookup"><span data-stu-id="68b37-192">See [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) in Unity</span></span>

    <span data-ttu-id="68b37-193">b) il tipo di Collider in Unity presenta caratteristiche di prestazioni notevolmente diverse.</span><span class="sxs-lookup"><span data-stu-id="68b37-193">b) The type of colliders in Unity have widely different performance characteristics.</span></span> <span data-ttu-id="68b37-194">Nell'ordine seguente sono elencati i Collider più performanti per i Collider meno performanti da sinistra verso destra.</span><span class="sxs-lookup"><span data-stu-id="68b37-194">The order below lists the most performant colliders to least performant colliders from left to right.</span></span> <span data-ttu-id="68b37-195">È più importante evitare i conflitti di rete che sono sostanzialmente più costosi rispetto ai Collider primitivi.</span><span class="sxs-lookup"><span data-stu-id="68b37-195">It is most important to avoid Mesh Colliders which are substantially more expensive than the primitive colliders.</span></span>

        Sphere < Capsule < Box <<< Mesh (Convex) < Mesh (non-Convex)

    <span data-ttu-id="68b37-196">Vedere le [procedure consigliate per la fisica di Unity](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) per altre informazioni</span><span class="sxs-lookup"><span data-stu-id="68b37-196">See [Unity Physics Best Practices](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) for more info</span></span>

2) <span data-ttu-id="68b37-197">**Animazioni**</span><span class="sxs-lookup"><span data-stu-id="68b37-197">**Animations**</span></span>

    <span data-ttu-id="68b37-198">Disabilitare le animazioni inattive disabilitando il componente animatore (la disabilitazione dell'oggetto gioco non avrà lo stesso effetto).</span><span class="sxs-lookup"><span data-stu-id="68b37-198">Disable idle animations by disabling the Animator component (disabling the game object won't have the same effect).</span></span> <span data-ttu-id="68b37-199">Evitare modelli di progettazione in cui un animatore si trova in un ciclo che imposta un valore sullo stesso elemento.</span><span class="sxs-lookup"><span data-stu-id="68b37-199">Avoid design patterns where an animator sits in a loop setting a value to the same thing.</span></span> <span data-ttu-id="68b37-200">Si verifica un notevole sovraccarico per questa tecnica, senza alcun effetto sull'applicazione.</span><span class="sxs-lookup"><span data-stu-id="68b37-200">There is considerable overhead for this technique, with no effect on the application.</span></span> [<span data-ttu-id="68b37-201">Altre informazioni sono disponibili qui.</span><span class="sxs-lookup"><span data-stu-id="68b37-201">Learn more here.</span></span>](https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html)

3) <span data-ttu-id="68b37-202">**Algoritmi complessi**</span><span class="sxs-lookup"><span data-stu-id="68b37-202">**Complex algorithms**</span></span>

    <span data-ttu-id="68b37-203">Se l'applicazione usa algoritmi complessi, ad esempio cinematica inversa, ricerca di percorsi e così via, cercare di trovare un approccio più semplice o modificare le impostazioni rilevanti per le relative prestazioni</span><span class="sxs-lookup"><span data-stu-id="68b37-203">If your application is using complex algorithms such as inverse kinematics, path finding, etc, look to find a simpler approach or adjust relevant settings for their performance</span></span>

## <a name="cpu-to-gpu-performance-recommendations"></a><span data-ttu-id="68b37-204">Raccomandazioni sulle prestazioni da CPU a GPU</span><span class="sxs-lookup"><span data-stu-id="68b37-204">CPU-to-GPU performance recommendations</span></span>

<span data-ttu-id="68b37-205">In genere, le prestazioni da CPU a GPU si verificano nelle **chiamate di estrazione** inviate alla scheda grafica.</span><span class="sxs-lookup"><span data-stu-id="68b37-205">Generally, CPU-to-GPU performance comes down to the **draw calls** submitted to the graphics card.</span></span> <span data-ttu-id="68b37-206">Per migliorare le prestazioni, le chiamate di progetto devono essere strategicamente **ridotte** o **b) ristrutturate** per ottenere risultati ottimali.</span><span class="sxs-lookup"><span data-stu-id="68b37-206">To improve performance, draw calls need to be strategically **a) reduced** or **b) restructured** for optimal results.</span></span> <span data-ttu-id="68b37-207">Poiché le chiamate di progetto sono a elevato utilizzo di risorse, la loro riduzione ridurrà il lavoro complessivo richiesto.</span><span class="sxs-lookup"><span data-stu-id="68b37-207">Since draw calls themselves are resource-intensive, reducing them will reduce overall work required.</span></span> <span data-ttu-id="68b37-208">Inoltre, le modifiche di stato tra le chiamate di un progetto richiedono una procedura di convalida e conversione costose nel driver di grafica e, di conseguenza, la ristrutturazione delle chiamate di progetto dell'applicazione per limitare le modifiche di stato (ad esempio</span><span class="sxs-lookup"><span data-stu-id="68b37-208">Further, state changes between draw calls requires costly validation and translation steps in the graphics driver and thus, restructuring of your application's draw calls to limit state changes(i.e</span></span> <span data-ttu-id="68b37-209">diversi materiali e così via possono migliorare le prestazioni.</span><span class="sxs-lookup"><span data-stu-id="68b37-209">different materials, etc) can boost performance.</span></span>

<span data-ttu-id="68b37-210">Unity è un ottimo articolo che offre una panoramica e una panoramica delle chiamate di estrazione in batch per la piattaforma.</span><span class="sxs-lookup"><span data-stu-id="68b37-210">Unity has a great article that gives an overview and dives into batching draw calls for their platform.</span></span>
- [<span data-ttu-id="68b37-211">Batch di chiamate di progetto Unity</span><span class="sxs-lookup"><span data-stu-id="68b37-211">Unity Draw Call Batching</span></span>](https://docs.unity3d.com/Manual/DrawCallBatching.html)

#### <a name="single-pass-instanced-rendering"></a><span data-ttu-id="68b37-212">Rendering con istanza a passaggio singolo</span><span class="sxs-lookup"><span data-stu-id="68b37-212">Single pass instanced rendering</span></span>

<span data-ttu-id="68b37-213">Il rendering a istanza singola di single pass in Unity consente la riduzione delle chiamate di progetto per ogni occhio a una chiamata di progetto con istanza.</span><span class="sxs-lookup"><span data-stu-id="68b37-213">Single Pass Instanced Rendering in Unity allows for draw calls for each eye to be reduced down to one instanced draw call.</span></span> <span data-ttu-id="68b37-214">A causa della memorizzazione nella cache di coerenza tra due chiamate di progetto, è anche possibile migliorare le prestazioni della GPU.</span><span class="sxs-lookup"><span data-stu-id="68b37-214">Due to cache coherency between two draw calls, there is also some performance improvement on the GPU as well.</span></span>

<span data-ttu-id="68b37-215">Per abilitare questa funzionalità nel progetto Unity</span><span class="sxs-lookup"><span data-stu-id="68b37-215">To enable this feature in your Unity Project</span></span>
1)  <span data-ttu-id="68b37-216">Aprire **le impostazioni di Player XR** (per **modificare** le impostazioni del **progetto** >  > **lettore** > **XR**)</span><span class="sxs-lookup"><span data-stu-id="68b37-216">Open **Player XR Settings** (go to **Edit** > **Project Settings** > **Player** > **XR Settings**)</span></span>
2) <span data-ttu-id="68b37-217">Selezionare **istanza passaggio singolo** dal menu a discesa **metodo di rendering stereo** (casella di controllo**Virtual Reality supported** )</span><span class="sxs-lookup"><span data-stu-id="68b37-217">Select **Single Pass Instanced** from the **Stereo Rendering Method** drop-down menu (**Virtual Reality Supported** checkbox must be checked)</span></span>

<span data-ttu-id="68b37-218">Per informazioni dettagliate su questo approccio di rendering, vedere gli articoli seguenti di Unity.</span><span class="sxs-lookup"><span data-stu-id="68b37-218">Read the following articles from Unity for details with this rendering approach.</span></span>
- [<span data-ttu-id="68b37-219">Come ottimizzare le prestazioni di AR e VR con il rendering stereo avanzato</span><span class="sxs-lookup"><span data-stu-id="68b37-219">How to maximize AR and VR performance with advanced stereo rendering</span></span>](https://blogs.unity3d.com/2017/11/21/how-to-maximize-ar-and-vr-performance-with-advanced-stereo-rendering/)
- [<span data-ttu-id="68b37-220">Istanze Single Pass</span><span class="sxs-lookup"><span data-stu-id="68b37-220">Single Pass Instancing</span></span>](https://docs.unity3d.com/Manual/SinglePassInstancing.html) 

>[!NOTE]
> <span data-ttu-id="68b37-221">Si verifica un problema comune con il rendering con istanze di single pass se gli sviluppatori dispongono già di shader personalizzati non scritti per le istanze.</span><span class="sxs-lookup"><span data-stu-id="68b37-221">One common issue with Single Pass Instanced Rendering occurs if developers already have existing custom shaders not written for instancing.</span></span> <span data-ttu-id="68b37-222">Dopo l'abilitazione di questa funzionalità, gli sviluppatori possono notare che GameObject solo il rendering in un solo occhio.</span><span class="sxs-lookup"><span data-stu-id="68b37-222">After enabling this feature, developers may notice some GameObjects only render in one eye.</span></span> <span data-ttu-id="68b37-223">Ciò è dovuto al fatto che gli shader personalizzati associati non dispongono delle proprietà appropriate per le istanze.</span><span class="sxs-lookup"><span data-stu-id="68b37-223">This is because the associated custom shaders do not have the appropriate properties for instancing.</span></span>
>
> <span data-ttu-id="68b37-224">Per informazioni su come risolvere questo problema, vedere [rendering stereo a passaggio singolo per HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) da Unity</span><span class="sxs-lookup"><span data-stu-id="68b37-224">See [Single Pass Stereo Rendering for HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) from Unity for how to address this problem</span></span>

#### <a name="static-batching"></a><span data-ttu-id="68b37-225">Batch statico</span><span class="sxs-lookup"><span data-stu-id="68b37-225">Static batching</span></span>

<span data-ttu-id="68b37-226">Unity è in grado di raggruppare molti oggetti statici per ridurre le chiamate di progetto alla GPU.</span><span class="sxs-lookup"><span data-stu-id="68b37-226">Unity is able to batch many static objects to reduce draw calls to the GPU.</span></span> <span data-ttu-id="68b37-227">Il batch statico funziona per la maggior parte degli oggetti [renderer](https://docs.unity3d.com/ScriptReference/Renderer.html) in Unity che **1) condividono lo stesso materiale** e **2) sono tutti contrassegnati come *statici***  (selezionare un oggetto in Unity e fare clic sulla casella di controllo nella parte superiore destra del controllo).</span><span class="sxs-lookup"><span data-stu-id="68b37-227">Static Batching works for most [Renderer](https://docs.unity3d.com/ScriptReference/Renderer.html) objects in Unity that **1) share the same material** and **2) are all marked as *Static*** (Select an object in Unity and click the checkbox in the top right of the inspector).</span></span> <span data-ttu-id="68b37-228">GameObject contrassegnato come *static* non può essere spostato nell'intero runtime dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="68b37-228">GameObjects marked as *Static* cannot be moved throughout your application's runtime.</span></span> <span data-ttu-id="68b37-229">Pertanto, il batch statico può essere difficile da usare in HoloLens, in cui virtualmente ogni oggetto deve essere inserito, spostato, ridimensionato e così via. Per gli auricolari immersivi, il batch statico può ridurre notevolmente le chiamate di disegni e migliorare le prestazioni.</span><span class="sxs-lookup"><span data-stu-id="68b37-229">Thus, static batching can be difficult to leverage on HoloLens where virtually every object needs to be placed, moved, scaled, etc. For immersive headsets, static batching can dramatically reduce draw calls and thus improve performance.</span></span>

<span data-ttu-id="68b37-230">Per ulteriori informazioni, vedere batch *statici* in [batch di chiamate di chiamata in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) .</span><span class="sxs-lookup"><span data-stu-id="68b37-230">Read *Static Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for more details.</span></span>

#### <a name="dynamic-batching"></a><span data-ttu-id="68b37-231">Suddivisione in batch dinamica</span><span class="sxs-lookup"><span data-stu-id="68b37-231">Dynamic batching</span></span>

<span data-ttu-id="68b37-232">Poiché è problematico contrassegnare gli oggetti come *statici* per lo sviluppo di HoloLens, l'invio in batch dinamici può essere un ottimo strumento per compensare questa funzionalità mancante.</span><span class="sxs-lookup"><span data-stu-id="68b37-232">Since it is problematic to mark objects as *Static* for HoloLens development, dynamic batching can be a great tool to compensate for this lacking feature.</span></span> <span data-ttu-id="68b37-233">Naturalmente, può essere utile anche per gli auricolari immersivi.</span><span class="sxs-lookup"><span data-stu-id="68b37-233">Of course, it is can also be useful on immersive headsets as well.</span></span> <span data-ttu-id="68b37-234">La suddivisione in batch dinamica in Unity può tuttavia essere difficile da abilitare perché GameObject deve **condividere lo stesso materiale** e **b) soddisfare un lungo elenco di altri criteri**.</span><span class="sxs-lookup"><span data-stu-id="68b37-234">Dynamic batching in Unity can be difficult though to enable because GameObjects must **a) share the same Material** and **b) meet a long list of other criteria**.</span></span>

<span data-ttu-id="68b37-235">Per l'elenco completo, leggere *batch dinamici* in [batch di chiamate di chiamata](https://docs.unity3d.com/Manual/DrawCallBatching.html) .</span><span class="sxs-lookup"><span data-stu-id="68b37-235">Read *Dynamic Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for the full list.</span></span> <span data-ttu-id="68b37-236">In genere, GameObject non è più valido per l'invio in batch in modo dinamico perché i dati di mesh associati non possono essere più di 300 vertici.</span><span class="sxs-lookup"><span data-stu-id="68b37-236">Most commonly, GameObjects become invalid to be batched dynamically because the associated mesh data can be no more than 300 vertices.</span></span>

#### <a name="other-techniques"></a><span data-ttu-id="68b37-237">Altre tecniche</span><span class="sxs-lookup"><span data-stu-id="68b37-237">Other techniques</span></span>

<span data-ttu-id="68b37-238">L'invio in batch può verificarsi solo se più GameObject sono in grado di condividere lo stesso materiale.</span><span class="sxs-lookup"><span data-stu-id="68b37-238">Batching can only occur if multiple GameObjects are able to share the same material.</span></span> <span data-ttu-id="68b37-239">Questa operazione viene in genere bloccata dalla necessità che GameObject disponga di una trama univoca per il rispettivo materiale.</span><span class="sxs-lookup"><span data-stu-id="68b37-239">Typically this will be blocked by the need for GameObjects to have a unique texture for their respective Material.</span></span> <span data-ttu-id="68b37-240">È comune combinare le trame in un'unica trama, un metodo noto come [Atlante delle trame](https://en.wikipedia.org/wiki/Texture_atlas).</span><span class="sxs-lookup"><span data-stu-id="68b37-240">It is common to combine Textures into one big Texture, a method known as [Texture Atlasing](https://en.wikipedia.org/wiki/Texture_atlas).</span></span>

<span data-ttu-id="68b37-241">Inoltre, in genere è preferibile combinare le mesh in una GameObject, ove possibile e ragionevole.</span><span class="sxs-lookup"><span data-stu-id="68b37-241">Further, it is generally preferable to combine meshes into one GameObject where possible and reasonable.</span></span> <span data-ttu-id="68b37-242">A ogni renderer in Unity sarà associata una o più chiamate di disegni e l'invio di una mesh combinata sotto un renderer.</span><span class="sxs-lookup"><span data-stu-id="68b37-242">Each Renderer in Unity will have it's associated draw call(s) versus submitting a combined mesh under one Renderer.</span></span>

>[!NOTE]
> <span data-ttu-id="68b37-243">Se si modificano le proprietà di renderer. Material in fase di esecuzione, viene creata una copia del materiale e, di conseguenza, si interrompe il batch.</span><span class="sxs-lookup"><span data-stu-id="68b37-243">Modifying properties of Renderer.material at runtime will create a copy of the Material and thus potentially break batching.</span></span> <span data-ttu-id="68b37-244">Utilizzare renderer. sharedMaterial per modificare le proprietà del materiale condiviso tra GameObject.</span><span class="sxs-lookup"><span data-stu-id="68b37-244">Use Renderer.sharedMaterial to modify shared material properties across GameObjects.</span></span>

## <a name="gpu-performance-recommendations"></a><span data-ttu-id="68b37-245">Suggerimenti sulle prestazioni della GPU</span><span class="sxs-lookup"><span data-stu-id="68b37-245">GPU performance recommendations</span></span>

<span data-ttu-id="68b37-246">Altre informazioni sull' [ottimizzazione del rendering della grafica in Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span><span class="sxs-lookup"><span data-stu-id="68b37-246">Learn more about [optimizing graphics rendering in Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span></span>

### <a name="optimize-depth-buffer-sharing"></a><span data-ttu-id="68b37-247">Ottimizzare la condivisione del buffer di profondità</span><span class="sxs-lookup"><span data-stu-id="68b37-247">Optimize depth buffer sharing</span></span>

<span data-ttu-id="68b37-248">È in genere consigliabile abilitare la **condivisione del buffer di profondità** nelle **impostazioni del lettore XR** per ottimizzare la [stabilità degli ologrammi](Hologram-stability.md).</span><span class="sxs-lookup"><span data-stu-id="68b37-248">It is generally recommended to enable **Depth buffer sharing** under **Player XR Settings** to optimize for [hologram stability](Hologram-stability.md).</span></span> <span data-ttu-id="68b37-249">Quando si Abilita la riproiezione in fase avanzata basata sulla profondità con questa impostazione, tuttavia, è consigliabile selezionare il **formato di profondità a 16 bit** anziché il **formato di profondità a 24 bit**.</span><span class="sxs-lookup"><span data-stu-id="68b37-249">When enabling depth-based late-stage reprojection with this setting however, it is recommended to select **16-bit depth format** instead of **24-bit depth format**.</span></span> <span data-ttu-id="68b37-250">I buffer di profondità a 16 bit ridurranno drasticamente la larghezza di banda e quindi il potere associato al traffico del buffer di profondità.</span><span class="sxs-lookup"><span data-stu-id="68b37-250">The 16-bit depth buffers will drastically reduces the bandwidth (and thus power) associated with depth buffer traffic.</span></span> <span data-ttu-id="68b37-251">Può trattarsi di una grande vittoria sia nella riduzione dell'energia che nel miglioramento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="68b37-251">This can be a big win both in power reduction and performance improvement.</span></span> <span data-ttu-id="68b37-252">Tuttavia, esistono due possibili risultati negativi utilizzando il *formato di profondità a 16 bit*.</span><span class="sxs-lookup"><span data-stu-id="68b37-252">However, there are two possible negative outcomes by using *16-bit depth format*.</span></span>

<span data-ttu-id="68b37-253">**Combattimento Z**</span><span class="sxs-lookup"><span data-stu-id="68b37-253">**Z-Fighting**</span></span>

<span data-ttu-id="68b37-254">La fedeltà ridotta della gamma di profondità rende più probabile che si verifichi un [conflitto z](https://en.wikipedia.org/wiki/Z-fighting) con 16 bit rispetto a 24 bit.</span><span class="sxs-lookup"><span data-stu-id="68b37-254">The reduced depth range fidelity makes [z-fighting](https://en.wikipedia.org/wiki/Z-fighting) more likely to occur with 16-bit than 24-bit.</span></span> <span data-ttu-id="68b37-255">Per evitare questi artefatti, modificare i piani di ritaglio vicini/lontani della [fotocamera Unity](https://docs.unity3d.com/Manual/class-Camera.html) per tenere conto della precisione più bassa.</span><span class="sxs-lookup"><span data-stu-id="68b37-255">To avoid these artifacts, modify the near/far clip planes of the [Unity camera](https://docs.unity3d.com/Manual/class-Camera.html) to account for the lower precision.</span></span> <span data-ttu-id="68b37-256">Per le applicazioni basate su HoloLens, un piano di ritaglio fino a 50m anziché l'impostazione predefinita di Unity 1000 è in genere in grado di eliminare qualsiasi combattimento z.</span><span class="sxs-lookup"><span data-stu-id="68b37-256">For HoloLens-based applications, a far clip plane of 50m instead of the Unity default 1000m can generally eliminate any z-fighting.</span></span>

<span data-ttu-id="68b37-257">**Buffer stencil disabilitato**</span><span class="sxs-lookup"><span data-stu-id="68b37-257">**Disabled Stencil Buffer**</span></span>

<span data-ttu-id="68b37-258">Quando Unity crea una [trama di rendering con profondità a 16 bit](https://docs.unity3d.com/ScriptReference/RenderTexture-depth.html), non è stato creato alcun buffer dello stencil.</span><span class="sxs-lookup"><span data-stu-id="68b37-258">When Unity creates a [Render Texture with 16-bit depth](https://docs.unity3d.com/ScriptReference/RenderTexture-depth.html), there is no stencil buffer created.</span></span> <span data-ttu-id="68b37-259">Selezionando il formato di profondità a 24 bit, la documentazione per Unity, creerà un buffer z a 24 bit, oltre a un [buffer di stencil a 8 bit](https://docs.unity3d.com/Manual/SL-Stencil.html) (se 32 bit è applicabile nel dispositivo, che in genere è il caso, ad esempio HoloLens).</span><span class="sxs-lookup"><span data-stu-id="68b37-259">Selecting 24-bit depth format, per Unity documentation, will create a 24-bit z-buffer as well as an [8-bit stencil buffer](https://docs.unity3d.com/Manual/SL-Stencil.html) (if 32-bit is applicable on device which is generally the case such as HoloLens).</span></span>

### <a name="avoid-full-screen-effects"></a><span data-ttu-id="68b37-260">Evitare effetti a schermo intero</span><span class="sxs-lookup"><span data-stu-id="68b37-260">Avoid full-screen effects</span></span>

<span data-ttu-id="68b37-261">Le tecniche che operano sull'intero schermo possono essere piuttosto onerose perché il loro ordine di grandezza è costituito da milioni di operazioni ogni frame.</span><span class="sxs-lookup"><span data-stu-id="68b37-261">Techniques that operate on the full screen can be quite expensive since their order of magnitude is millions of operations every frame.</span></span> <span data-ttu-id="68b37-262">È quindi consigliabile evitare [gli effetti di post-elaborazione](https://docs.unity3d.com/Manual/PostProcessingOverview.html) , ad esempio l'anti-aliasing, Bloom e altro ancora.</span><span class="sxs-lookup"><span data-stu-id="68b37-262">Thus, it is recommended to avoid [post-processing effects](https://docs.unity3d.com/Manual/PostProcessingOverview.html) such as anti-aliasing, bloom, and more.</span></span>

### <a name="optimal-lighting-settings"></a><span data-ttu-id="68b37-263">Impostazioni di illuminazione ottimali</span><span class="sxs-lookup"><span data-stu-id="68b37-263">Optimal lighting settings</span></span>

<span data-ttu-id="68b37-264">L' [illuminazione globale in tempo reale](https://docs.unity3d.com/Manual/GIIntro.html) in Unity può fornire risultati visivi in attesa, ma comporta calcoli di illuminazione piuttosto costosi.</span><span class="sxs-lookup"><span data-stu-id="68b37-264">[Real-time Global Illumination](https://docs.unity3d.com/Manual/GIIntro.html) in Unity can provide outstanding visual results but involves quite expensive lighting calculations.</span></span> <span data-ttu-id="68b37-265">È consigliabile disabilitare l'illuminazione globale in tempo reale per ogni file di scena Unity tramite **finestra** > **rendering** > **impostazioni di illuminazione** > deselezionare l' **illuminazione globale in tempo reale**.</span><span class="sxs-lookup"><span data-stu-id="68b37-265">It is recommended to disable Realtime Global Illumination for every Unity scene file via **Window** > **Rendering** > **Lighting Settings** > Uncheck **Real-time Global Illumination**.</span></span>

<span data-ttu-id="68b37-266">Si consiglia inoltre di disabilitare tutti i cast di Shadow, perché aggiungono anche costosi passaggi GPU a una scena Unity.</span><span class="sxs-lookup"><span data-stu-id="68b37-266">Further, it is recommended to disable all shadow casting as these also add expensive GPU passes onto a Unity scene.</span></span> <span data-ttu-id="68b37-267">Le ombreggiature possono essere disabilitate per luce ma possono anche essere controllate in maniera olistica tramite le impostazioni di qualità.</span><span class="sxs-lookup"><span data-stu-id="68b37-267">Shadows can be disable per light but can also be controlled holistically via Quality settings.</span></span>

<span data-ttu-id="68b37-268">**Modificare** > **Impostazioni progetto**, quindi selezionare la categoria **qualità** > selezionare la **qualità bassa** per la piattaforma UWP.</span><span class="sxs-lookup"><span data-stu-id="68b37-268">**Edit** > **Project Settings**, then select the **Quality** category > Select **Low Quality** for the UWP Platform.</span></span> <span data-ttu-id="68b37-269">È anche possibile impostare la proprietà **Shadows** solo per **disabilitare le ombreggiature**.</span><span class="sxs-lookup"><span data-stu-id="68b37-269">One can also just set the **Shadows** property to **Disable Shadows**.</span></span>

### <a name="reduce-poly-count"></a><span data-ttu-id="68b37-270">Ridurre il numero di Poly</span><span class="sxs-lookup"><span data-stu-id="68b37-270">Reduce poly count</span></span>

<span data-ttu-id="68b37-271">Il numero di poligoni viene in genere ridotto da uno</span><span class="sxs-lookup"><span data-stu-id="68b37-271">Polygon count is usually reduced by either</span></span>
1) <span data-ttu-id="68b37-272">Rimozione di oggetti da una scena</span><span class="sxs-lookup"><span data-stu-id="68b37-272">Removing objects from a scene</span></span>
2) <span data-ttu-id="68b37-273">Decimazione di asset che riduce il numero di poligoni per una determinata mesh</span><span class="sxs-lookup"><span data-stu-id="68b37-273">Asset decimation which reduces the number of polygons for a given mesh</span></span>
3) <span data-ttu-id="68b37-274">Implementazione di un [sistema di livello di dettaglio (LOD)](https://docs.unity3d.com/Manual/LevelOfDetail.html) nell'applicazione che esegue il rendering di oggetti lontani con una versione meno poligonale della stessa geometria</span><span class="sxs-lookup"><span data-stu-id="68b37-274">Implementing a [Level of Detail (LOD) System](https://docs.unity3d.com/Manual/LevelOfDetail.html) into your application which renders far away objects with lower-polygon version of the same geometry</span></span>

### <a name="understanding-shaders-in-unity"></a><span data-ttu-id="68b37-275">Informazioni sugli shader in Unity</span><span class="sxs-lookup"><span data-stu-id="68b37-275">Understanding shaders in Unity</span></span>

<span data-ttu-id="68b37-276">Una semplice approssimazione per confrontare gli shader nelle prestazioni consiste nell'identificare il numero medio di operazioni eseguite in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="68b37-276">An easy approximation to compare shaders in performance is to identify the average number of operations each executes at runtime.</span></span> <span data-ttu-id="68b37-277">Questa operazione può essere eseguita facilmente in Unity.</span><span class="sxs-lookup"><span data-stu-id="68b37-277">This can be done easily in Unity.</span></span>

1) <span data-ttu-id="68b37-278">Selezionare l'asset shader o selezionare un materiale, quindi nell'angolo superiore destro della finestra di controllo, selezionare l'icona a forma di ingranaggio e quindi **"Seleziona shader"** .</span><span class="sxs-lookup"><span data-stu-id="68b37-278">Select your shader asset or select a material, then in top right corner of the inspector window, select the gear icon and then **"Select Shader"**</span></span>

    ![Seleziona shader in Unity](images/Select-shader-unity.png)
2) <span data-ttu-id="68b37-280">Con l'asset shader selezionato, fare clic sul pulsante **"Compila e Mostra codice"** nella finestra di controllo</span><span class="sxs-lookup"><span data-stu-id="68b37-280">With the shader asset selected, click the **"Compile and show code"** button under the inspector window</span></span>

    ![Compila il codice dello shader in Unity](images/compile-shader-code-unity.PNG)

3) <span data-ttu-id="68b37-282">Dopo la compilazione, cercare la sezione statistiche nei risultati con il numero di operazioni diverse per il vertice e la pixel shader (Nota: i pixel shader sono spesso denominati anche frammenti shader)</span><span class="sxs-lookup"><span data-stu-id="68b37-282">After compiling, look for the statistics section in the results with the number of different operations for both the vertex and pixel shader (Note: pixel shaders are often also called fragment shaders)</span></span>

    ![Operazioni standard di Unity shader](images/unity-standard-shader-compilation.png)

#### <a name="optimize-pixel-shaders"></a><span data-ttu-id="68b37-284">Ottimizza pixel shader</span><span class="sxs-lookup"><span data-stu-id="68b37-284">Optimize pixel shaders</span></span>

<span data-ttu-id="68b37-285">Esaminando i risultati statistici compilati utilizzando il metodo precedente, il [frammento shader](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) eseguirà in genere più operazioni rispetto al [vertex shader](https://en.wikipedia.org/wiki/Shader#Vertex_shaders) in media.</span><span class="sxs-lookup"><span data-stu-id="68b37-285">Looking at the compiled statistic results using the method above, the [fragment shader](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) will generally execute more operations than the [vertex shader](https://en.wikipedia.org/wiki/Shader#Vertex_shaders) on average.</span></span> <span data-ttu-id="68b37-286">Il frammento shader, noto anche come pixel shader, viene eseguito per ogni pixel nell'output dello schermo, mentre il vertex shader viene eseguito solo per ogni vertice di tutte le mesh disegnate sullo schermo.</span><span class="sxs-lookup"><span data-stu-id="68b37-286">The fragment shader, also known as the pixel shader, is executed per pixel on the screen output while the vertex shader is only executed per-vertex of all meshes being drawn to the screen.</span></span> 

<span data-ttu-id="68b37-287">Pertanto, non solo gli shader di frammento hanno più istruzioni rispetto ai vertex shader a causa di tutti i calcoli di illuminazione, i frammenti shader vengono quasi sempre eseguiti su un set di dati più grande.</span><span class="sxs-lookup"><span data-stu-id="68b37-287">Thus, not only do fragment shaders have more instructions than vertex shaders because of all the lighting calculations, fragment shaders are almost always executed on a larger dataset.</span></span> <span data-ttu-id="68b37-288">Se, ad esempio, l'output della schermata è un'immagine 2K per 2K, il frammento shader può essere eseguito 2000 \* 2000 = 4 milioni volte.</span><span class="sxs-lookup"><span data-stu-id="68b37-288">For example, if the screen output is a 2k by 2k image, then the fragment shader can get executed 2,000\*2,000 = 4,000,000 times.</span></span> <span data-ttu-id="68b37-289">Se si esegue il rendering di due occhi, questo numero raddoppia perché sono presenti due schermate.</span><span class="sxs-lookup"><span data-stu-id="68b37-289">If rendering two eyes, this number doubles since there are two screens.</span></span> <span data-ttu-id="68b37-290">Se un'applicazione di realtà mista ha più sessioni, effetti di post-elaborazione a schermo intero o il rendering di più mesh sullo stesso pixel, questo numero aumenterà in modo significativo.</span><span class="sxs-lookup"><span data-stu-id="68b37-290">If a mixed reality application has multiple passes, full-screen post-processing effects, or rendering multiple meshes to the same pixel, this number will increase dramatically.</span></span> 

<span data-ttu-id="68b37-291">Pertanto, la riduzione del numero di operazioni nel frammento shader può in genere offrire un miglioramento delle prestazioni notevolmente maggiore rispetto alle ottimizzazioni nel vertex shader.</span><span class="sxs-lookup"><span data-stu-id="68b37-291">Therefore, reducing the number of operations in the fragment shader can generally give far greater performance gains over optimizations in the vertex shader.</span></span>

#### <a name="unity-standard-shader-alternatives"></a><span data-ttu-id="68b37-292">Alternative shader standard Unity</span><span class="sxs-lookup"><span data-stu-id="68b37-292">Unity Standard shader alternatives</span></span>

<span data-ttu-id="68b37-293">Invece di usare un rendering fisico (PBR) o un altro shader di alta qualità, vedere uso di uno shader più efficiente e più economico.</span><span class="sxs-lookup"><span data-stu-id="68b37-293">Instead of using a physically based rendering (PBR) or other high-quality shader, look at utilizing a more performant and cheaper shader.</span></span> <span data-ttu-id="68b37-294">Il [Toolkit di realtà mista](https://github.com/Microsoft/MixedRealityToolkit-Unity) fornisce lo [shader standard MRTK](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) ottimizzato per i progetti di realtà mista.</span><span class="sxs-lookup"><span data-stu-id="68b37-294">The [Mixed Reality Toolkit](https://github.com/Microsoft/MixedRealityToolkit-Unity) provides the [MRTK standard shader](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) that has been optimized for mixed reality projects.</span></span>

<span data-ttu-id="68b37-295">Unity offre anche un'opzione di shader non illuminata, con vertice, diffusa e altre opzioni semplificate che risultano significativamente più veloci rispetto allo shader standard di Unity.</span><span class="sxs-lookup"><span data-stu-id="68b37-295">Unity also provides an unlit, vertex lit, diffuse, and other simplified shader options that are significantly faster compared to the Unity Standard shader.</span></span> <span data-ttu-id="68b37-296">Per informazioni più dettagliate, vedere [utilizzo e prestazioni degli shader incorporati](https://docs.unity3d.com/Manual/shader-Performance.html) .</span><span class="sxs-lookup"><span data-stu-id="68b37-296">See [Usage and Performance of Built-in Shaders](https://docs.unity3d.com/Manual/shader-Performance.html) for more detailed information.</span></span>

#### <a name="shader-preloading"></a><span data-ttu-id="68b37-297">Precaricamento shader</span><span class="sxs-lookup"><span data-stu-id="68b37-297">Shader preloading</span></span>

<span data-ttu-id="68b37-298">Usare il *precaricamento dello shader* e altri trucchi per ottimizzare il [tempo di caricamento dello shader](https://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span><span class="sxs-lookup"><span data-stu-id="68b37-298">Use *Shader preloading* and other tricks to optimize [shader load time](https://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span></span> <span data-ttu-id="68b37-299">In particolare, il precaricamento dello shader significa che non verranno visualizzati intoppi a causa della compilazione dello shader di Runtime.</span><span class="sxs-lookup"><span data-stu-id="68b37-299">In particular, shader preloading means you won't see any hitches due to runtime shader compilation.</span></span>

### <a name="limit-overdraw"></a><span data-ttu-id="68b37-300">Limite di sovralievo</span><span class="sxs-lookup"><span data-stu-id="68b37-300">Limit overdraw</span></span>

<span data-ttu-id="68b37-301">In Unity, è possibile visualizzare il sovraprogetto per la scena, impostando il [**menu modalità**](https://docs.unity3d.com/Manual/ViewModes.html) di visualizzazione nell'angolo superiore sinistro della **visualizzazione scena** e selezionando **sovradisegnato**.</span><span class="sxs-lookup"><span data-stu-id="68b37-301">In Unity, one can display overdraw for their scene, by toggling the [**draw mode menu**](https://docs.unity3d.com/Manual/ViewModes.html) in the top left corner of the **Scene view** and selecting **Overdraw**.</span></span>

<span data-ttu-id="68b37-302">In genere, il sovraprogetto può essere mitigato eliminando gli oggetti in anticipo prima che vengano inviati alla GPU.</span><span class="sxs-lookup"><span data-stu-id="68b37-302">Generally, overdraw can be mitigated by culling objects ahead of time before they are sent to the GPU.</span></span> <span data-ttu-id="68b37-303">Unity fornisce informazioni dettagliate sull'implementazione dell' [abbattimento di occlusione](https://docs.unity3d.com/Manual/OcclusionCulling.html) per il motore.</span><span class="sxs-lookup"><span data-stu-id="68b37-303">Unity provides details on implementing [Occlusion Culling](https://docs.unity3d.com/Manual/OcclusionCulling.html) for their engine.</span></span>

## <a name="memory-recommendations"></a><span data-ttu-id="68b37-304">Consigli sulla memoria</span><span class="sxs-lookup"><span data-stu-id="68b37-304">Memory recommendations</span></span>

<span data-ttu-id="68b37-305">Un'allocazione eccessiva della memoria & operazioni di deallocazione possono avere effetti negativi sull'applicazione olografica, con prestazioni incoerenti, frame bloccati e altro comportamento dannoso.</span><span class="sxs-lookup"><span data-stu-id="68b37-305">Excessive memory allocation & deallocation operations can have adverse effects on your holographic application resulting in inconsistent performance, frozen frames, and other detrimental behavior.</span></span> <span data-ttu-id="68b37-306">È particolarmente importante comprendere le considerazioni sulla memoria durante lo sviluppo in Unity, perché la gestione della memoria è controllata dal Garbage Collector.</span><span class="sxs-lookup"><span data-stu-id="68b37-306">It is especially important to understand memory considerations when developing in Unity since memory management is controlled by the garbage collector.</span></span>

#### <a name="garbage-collection"></a><span data-ttu-id="68b37-307">Garbage Collection</span><span class="sxs-lookup"><span data-stu-id="68b37-307">Garbage collection</span></span>

<span data-ttu-id="68b37-308">Le app olografiche elimineranno l'elaborazione del tempo di calcolo nel Garbage Collector (GC) quando il GC viene attivato per analizzare gli oggetti che non sono più nell'ambito durante l'esecuzione e la memoria deve essere rilasciata in modo da poter essere resi disponibili per il riutilizzo.</span><span class="sxs-lookup"><span data-stu-id="68b37-308">Holographic apps will loose processing compute time to the garbage collector (GC) when the GC is activated to analyze objects that are no longer in scope during execution and their memory needs to be released so it can be made available for re-use.</span></span> <span data-ttu-id="68b37-309">Le allocazioni e le deallocazioni costanti richiedono in genere che l'Garbage Collector venga eseguita con maggiore frequenza, in modo da compromettere le prestazioni e l'esperienza utente.</span><span class="sxs-lookup"><span data-stu-id="68b37-309">Constant allocations and de-allocations will generally require the garbage collector to run more frequently thus hurting performance and user experience.</span></span>

<span data-ttu-id="68b37-310">Unity ha fornito una pagina eccellente che illustra in dettaglio il funzionamento del Garbage Collector e suggerimenti per scrivere codice più efficiente per quanto riguarda la gestione della memoria.</span><span class="sxs-lookup"><span data-stu-id="68b37-310">Unity has provided an excellent page that explains in detail how the garbage collector works and tips to write more efficient code in regards to memory management.</span></span>
- [<span data-ttu-id="68b37-311">Ottimizzazione Garbage Collection nei Giochi Unity</span><span class="sxs-lookup"><span data-stu-id="68b37-311">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)

<span data-ttu-id="68b37-312">Una delle procedure più comuni che porta a un numero eccessivo di Garbage Collection non è la memorizzazione nella cache dei riferimenti a componenti e classi nello sviluppo di Unity.</span><span class="sxs-lookup"><span data-stu-id="68b37-312">One of the most common practices that leads to excessive garbage collection is not caching references to components and classes in Unity development.</span></span> <span data-ttu-id="68b37-313">Tutti i riferimenti devono essere acquisiti durante l'avvio () o svegli () e riusati in funzioni successive, ad esempio Update () o LateUpdate ().</span><span class="sxs-lookup"><span data-stu-id="68b37-313">Any references should be captured during Start() or Awake() and re-used in later functions such as Update() or LateUpdate().</span></span>

<span data-ttu-id="68b37-314">Altri suggerimenti rapidi:</span><span class="sxs-lookup"><span data-stu-id="68b37-314">Other quick tips:</span></span>
- <span data-ttu-id="68b37-315">Usare la classe [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) C# per compilare in modo dinamico stringhe complesse in fase di esecuzione</span><span class="sxs-lookup"><span data-stu-id="68b37-315">Use the [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) C# class to dynamically build complex strings at runtime</span></span>
- <span data-ttu-id="68b37-316">Rimuovere le chiamate a debug. log () quando non sono più necessarie perché sono ancora in esecuzione in tutte le versioni di compilazione di un'app</span><span class="sxs-lookup"><span data-stu-id="68b37-316">Remove calls to Debug.Log() when no longer needed as they still execute in all build versions of an app</span></span>
- <span data-ttu-id="68b37-317">Se l'app olografica richiede in genere molta memoria, provare a chiamare [ _**System. GC. Collect ()**_ ](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) durante il caricamento di fasi, ad esempio quando si presenta una schermata di caricamento o di transizione</span><span class="sxs-lookup"><span data-stu-id="68b37-317">If your holographic app generally requires lots of memory, consider calling  [_**System.GC.Collect()**_](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) during loading phases such as when presenting a loading or transition screen</span></span>

#### <a name="object-pooling"></a><span data-ttu-id="68b37-318">Pool di oggetti</span><span class="sxs-lookup"><span data-stu-id="68b37-318">Object pooling</span></span>

<span data-ttu-id="68b37-319">Il pool di oggetti è una tecnica comune per ridurre il costo delle allocazioni continue & le deallocazioni di oggetti.</span><span class="sxs-lookup"><span data-stu-id="68b37-319">Object pooling is a popular technique to reduce the cost of continuous allocations & deallocations of objects.</span></span> <span data-ttu-id="68b37-320">Questa operazione viene eseguita allocando un pool di grandi dimensioni di oggetti identici e riutilizzando le istanze disponibili inattive da questo pool invece di generare ed eliminare costantemente gli oggetti nel tempo.</span><span class="sxs-lookup"><span data-stu-id="68b37-320">This is done by allocating a large pool of identical objects and re-using inactive, available instances from this pool instead of constantly spawning and destroying objects over time.</span></span> <span data-ttu-id="68b37-321">I pool di oggetti sono ottimi per i componenti riutilizzabili con durata variabile durante un'app.</span><span class="sxs-lookup"><span data-stu-id="68b37-321">Object pools are great for re-useable components that have variable lifetime during an app.</span></span>

- [<span data-ttu-id="68b37-322">Esercitazione sul pool di oggetti in Unity</span><span class="sxs-lookup"><span data-stu-id="68b37-322">Object Pooling Tutorial in Unity</span></span>](https://unity3d.com/learn/tutorials/topics/scripting/object-pooling) 

## <a name="startup-performance"></a><span data-ttu-id="68b37-323">Prestazioni di avvio</span><span class="sxs-lookup"><span data-stu-id="68b37-323">Startup performance</span></span>

<span data-ttu-id="68b37-324">È consigliabile avviare l'app con una scena più piccola, quindi usare *[SceneManager. LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* per caricare il resto della scena.</span><span class="sxs-lookup"><span data-stu-id="68b37-324">You should consider starting your app with a smaller scene, then using *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* to load the rest of the scene.</span></span> <span data-ttu-id="68b37-325">Ciò consente all'app di ottenere uno stato interattivo il più velocemente possibile.</span><span class="sxs-lookup"><span data-stu-id="68b37-325">This allows your app to get to an interactive state as fast as possible.</span></span> <span data-ttu-id="68b37-326">Tenere presente che potrebbe essere presente un picco di CPU elevato mentre è in corso l'attivazione della nuova scena e che qualsiasi contenuto sottoposto a rendering potrebbe balbettare o bloccarsi.</span><span class="sxs-lookup"><span data-stu-id="68b37-326">Be aware that there may be a large CPU spike while the new scene is being activated and that any rendered content might stutter or hitch.</span></span> <span data-ttu-id="68b37-327">Per ovviare a questo problema, è possibile impostare la proprietà AsyncOperation. allowSceneActivation su false sulla scena caricata, attendere il caricamento della scena, deselezionare la schermata su nero e quindi impostare di nuovo su true per completare l'attivazione della scena.</span><span class="sxs-lookup"><span data-stu-id="68b37-327">One way to work around this is to set the AsyncOperation.allowSceneActivation property to false on the scene being loaded, wait for the scene to load, clear the screen to black, and then set back to true to complete the scene activation.</span></span>

<span data-ttu-id="68b37-328">Tenere presente che, durante il caricamento della scena di avvio, la schermata iniziale olografica verrà visualizzata all'utente.</span><span class="sxs-lookup"><span data-stu-id="68b37-328">Remember that while the startup scene is loading the holographic splash screen will be displayed to the user.</span></span>

## <a name="see-also"></a><span data-ttu-id="68b37-329">Vedi anche</span><span class="sxs-lookup"><span data-stu-id="68b37-329">See also</span></span>
- [<span data-ttu-id="68b37-330">Ottimizzazione del rendering della grafica nei Giochi Unity</span><span class="sxs-lookup"><span data-stu-id="68b37-330">Optimizing graphics rendering in Unity games</span></span>](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games?playlist=44069)
- [<span data-ttu-id="68b37-331">Ottimizzazione Garbage Collection nei Giochi Unity</span><span class="sxs-lookup"><span data-stu-id="68b37-331">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)
- <span data-ttu-id="68b37-332">[Procedure consigliate per la fisica [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span><span class="sxs-lookup"><span data-stu-id="68b37-332">[Physics Best Practices [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span></span>
- <span data-ttu-id="68b37-333">[Ottimizzazione degli script [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span><span class="sxs-lookup"><span data-stu-id="68b37-333">[Optimizing Scripts [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span></span>
