---
title: Consigli sulle prestazioni per Unity
description: Suggerimenti specifici per Unity per migliorare le prestazioni con le app di realtà mista.
author: troy-ferrell
ms.author: trferrel
ms.date: 03/26/2019
ms.topic: article
keywords: grafica, cpu, gpu, rendering, garbage collection, hololens
ms.localizationpriority: high
ms.openlocfilehash: 28f09986cdb8c562aedfc9deae7b0369214ebc05
ms.sourcegitcommit: d6ac8f1f545fe20cf1e36b83c0e7998b82fd02f8
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 04/14/2020
ms.locfileid: "81277569"
---
# <a name="performance-recommendations-for-unity"></a><span data-ttu-id="cc2b3-104">Consigli sulle prestazioni per Unity</span><span class="sxs-lookup"><span data-stu-id="cc2b3-104">Performance recommendations for Unity</span></span>

<span data-ttu-id="cc2b3-105">Questo articolo si basa sugli argomenti affrontati in [Informazioni sulle prestazioni per la realtà mista](understanding-performance-for-mixed-reality.md), ma tratta in particolare i concetti specifici dell'ambiente del motore Unity.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-105">This article builds on the discussion outlined in [performance recommendations for mixed reality](understanding-performance-for-mixed-reality.md) but focuses on learnings specific to the Unity engine environment.</span></span>

## <a name="use-recommended-unity-project-settings"></a><span data-ttu-id="cc2b3-106">Usare le impostazioni consigliate per il progetto Unity</span><span class="sxs-lookup"><span data-stu-id="cc2b3-106">Use recommended Unity project settings</span></span>

<span data-ttu-id="cc2b3-107">Il primo passaggio più importante per l'ottimizzazione delle prestazioni delle app di realtà mista in Unity è assicurarsi di usare le [impostazioni di ambiente consigliate per Unity](recommended-settings-for-unity.md).</span><span class="sxs-lookup"><span data-stu-id="cc2b3-107">The most important first step when optimizing performance of mixed reality apps in Unity is to be sure you are using the [recommended environment settings for Unity](recommended-settings-for-unity.md).</span></span> <span data-ttu-id="cc2b3-108">Questo articolo include contenuto con alcune delle configurazioni scena più importanti per la creazione di app di realtà mista ad alte prestazioni.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-108">That article contains content with some of the most important scene configurations for building performant Mixed Reality apps.</span></span> <span data-ttu-id="cc2b3-109">Alcune di queste impostazioni consigliate sono poste in evidenza anche di seguito.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-109">Some of these recommended settings are highlighted below, as well.</span></span>

## <a name="how-to-profile-with-unity"></a><span data-ttu-id="cc2b3-110">Come eseguire la profilatura con Unity</span><span class="sxs-lookup"><span data-stu-id="cc2b3-110">How to profile with Unity</span></span>

<span data-ttu-id="cc2b3-111">Unity fornisce un **[profiler](https://docs.unity3d.com/Manual/Profiler.html)** incorporato, che si rivela un'ottima risorsa per raccogliere importanti informazioni sulle prestazioni per la tua app specifica.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-111">Unity provides the **[Unity Profiler](https://docs.unity3d.com/Manual/Profiler.html)** built-in, which is a great resource to gather valuable performance insights for your particular app.</span></span> <span data-ttu-id="cc2b3-112">Sebbene sia possibile eseguire il profiler nell'editor, queste metriche non rappresentano il vero ambiente di runtime e, di conseguenza, i risultati che ne derivano devono essere usati con cautela.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-112">Although one can run the profiler in-editor, these metrics do not represent the true runtime environment and thus, results from this should be used cautiously.</span></span> <span data-ttu-id="cc2b3-113">Per ottenere informazioni più accurate e utilizzabili, è consigliabile profilare in remoto l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-113">It is recommended to remotely profile your application while running on device for most accurate and actionable insights.</span></span> <span data-ttu-id="cc2b3-114">Anche [Frame Debugger](https://docs.unity3d.com/Manual/FrameDebugger.html) di Unity è uno strumento di analisi molto potente da usare.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-114">Further, Unity's [Frame Debugger](https://docs.unity3d.com/Manual/FrameDebugger.html) is also a very powerful and insight tool to utilize.</span></span>

<span data-ttu-id="cc2b3-115">Unity fornisce documentazione esauriente sugli argomenti seguenti:</span><span class="sxs-lookup"><span data-stu-id="cc2b3-115">Unity provides great documentation for:</span></span>
1) <span data-ttu-id="cc2b3-116">Come connettere il [profiler Unity alle applicazioni UWP in remoto](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span><span class="sxs-lookup"><span data-stu-id="cc2b3-116">How to connect the [Unity profiler to UWP applications remotely](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span></span>
2) <span data-ttu-id="cc2b3-117">Come [diagnosticare i problemi di prestazioni con il profiler Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window) in modo efficace</span><span class="sxs-lookup"><span data-stu-id="cc2b3-117">How to effectively [diagnose performance problems with the Unity Profiler](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span></span>

>[!NOTE]
> <span data-ttu-id="cc2b3-118">Con il profiler Unity connesso, e dopo aver aggiunto il profiler GPU (vedi *Add Profiler* (Aggiungi profiler) nell'angolo superiore destro), è possibile controllare nel profiler quanto tempo della CPU e della GPU viene impiegato.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-118">With the Unity Profiler connected and after adding the GPU profiler (see *Add Profiler* in top right corner), one can see how much time is being spent on the CPU & GPU respectively in the middle of the profiler.</span></span> <span data-ttu-id="cc2b3-119">Ciò consente allo sviluppatore di ottenere una rapida approssimazione se l'applicazione è associata alla CPU o alla GPU.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-119">This allows the developer to get a quick approximation if their application is CPU or GPU bounded.</span></span>
>
> ![CPU Unity e GPU](images/unity-profiler-cpu-gpu.png)

## <a name="cpu-performance-recommendations"></a><span data-ttu-id="cc2b3-121">Consigli sulle prestazioni della CPU</span><span class="sxs-lookup"><span data-stu-id="cc2b3-121">CPU performance recommendations</span></span>

<span data-ttu-id="cc2b3-122">Il contenuto seguente illustra più in dettaglio le procedure per migliorare le prestazioni, soprattutto per lo sviluppo in C# e Unity.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-122">The content below covers more in-depth performance practices, especially targeted for Unity & C# development.</span></span>

#### <a name="cache-references"></a><span data-ttu-id="cc2b3-123">Memorizzare nella cache i riferimenti</span><span class="sxs-lookup"><span data-stu-id="cc2b3-123">Cache references</span></span>

<span data-ttu-id="cc2b3-124">Come procedura consigliata, i riferimenti a tutti i componenti pertinenti e ai GameObject devono essere memorizzati nella cache durante l'inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-124">It is best practice to cache references to all relevant components and GameObjects at initialization.</span></span> <span data-ttu-id="cc2b3-125">Ciò è dovuto al fatto che le chiamate di funzioni ripetute, come ad esempio *[GetComponent\<T>()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* , sono molto più dispendiose se comparate con il costo in termini di memoria correlato all'archiviazione di un puntatore.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-125">This is because repeating function calls such as *[GetComponent\<T>()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* are significantly more expensive relative to the memory cost to store a pointer.</span></span> <span data-ttu-id="cc2b3-126">Questo vale anche per [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html), in uso regolarmente.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-126">This also applies to to the very regularly used [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html).</span></span> <span data-ttu-id="cc2b3-127">*Camera.main* in realtà usa solo *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* sotto, che con costi elevati cerca nel grafico della scena un oggetto camera con il tag *"MainCamera"* .</span><span class="sxs-lookup"><span data-stu-id="cc2b3-127">*Camera.main* actually just uses *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* underneath, which expensively searches your scene graph for a camera object with the *"MainCamera"* tag.</span></span>

```CS
using UnityEngine;
using System.Collections;

public class ExampleClass : MonoBehaviour
{
    private Camera cam;
    private CustomComponent comp;

    void Start() 
    {
        cam = Camera.main;
        comp = GetComponent<CustomComponent>();
    }

    void Update()
    {
        // Good
        this.transform.position = cam.transform.position + cam.transform.forward * 10.0f;

        // Bad
        this.transform.position = Camera.main.transform.position + Camera.main.transform.forward * 10.0f;

        // Good
        comp.DoSomethingAwesome();

        // Bad
        GetComponent<CustomComponent>().DoSomethingAwesome();
    }
}
```

>[!NOTE] 
> <span data-ttu-id="cc2b3-128">Evitare GetComponent(stringa)</span><span class="sxs-lookup"><span data-stu-id="cc2b3-128">Avoid GetComponent(string)</span></span> <br/>
> <span data-ttu-id="cc2b3-129">Quando usi *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* , si verificano overload diversi.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-129">When using *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)*, there are a handful of different overloads.</span></span> <span data-ttu-id="cc2b3-130">È importante usare sempre le implementazioni basate sul tipo e mai l'overload di ricerca basato su una stringa.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-130">It is important to always use the Type-based implementations and never the string-based searching overload.</span></span> <span data-ttu-id="cc2b3-131">La ricerca per stringa nella scena è notevolmente più costosa rispetto alla ricerca per tipo.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-131">Searching by string in your scene is significantly more costly than searching by Type.</span></span> <br/>
> <span data-ttu-id="cc2b3-132">(Utilizzabile) Component GetComponent(Type tipo)</span><span class="sxs-lookup"><span data-stu-id="cc2b3-132">(Good) Component GetComponent(Type type)</span></span> <br/>
> <span data-ttu-id="cc2b3-133">(Utilizzabile) T GetComponent\<T>()</span><span class="sxs-lookup"><span data-stu-id="cc2b3-133">(Good) T GetComponent\<T>()</span></span> <br/>
> <span data-ttu-id="cc2b3-134">(Da evitare) Component GetComponent(stringa)></span><span class="sxs-lookup"><span data-stu-id="cc2b3-134">(Bad) Component GetComponent(string)></span></span> <br/>

#### <a name="avoid-expensive-operations"></a><span data-ttu-id="cc2b3-135">Evitare operazioni costose</span><span class="sxs-lookup"><span data-stu-id="cc2b3-135">Avoid expensive operations</span></span>

1) <span data-ttu-id="cc2b3-136">**Evitare l'uso di [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span><span class="sxs-lookup"><span data-stu-id="cc2b3-136">**Avoid use of [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span></span>

    <span data-ttu-id="cc2b3-137">Benché il codice LINQ possa essere molto chiaro e facile da leggere e scrivere, in genere richiede molte più risorse di calcolo e soprattutto l'allocazione di una maggiore quantità di memoria rispetto alla scrittura manuale dell'algoritmo.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-137">Although LINQ can be very clean and easy to read and write, it generally requires much more computation and particularly more memory allocation than writing the algorithm out manually.</span></span>

    ```CS
    // Example Code
    using System.Linq;

    List<int> data = new List<int>();
    data.Any(x => x > 10);

    var result = from x in data
                 where x > 10
                 select x;
    ```

2) <span data-ttu-id="cc2b3-138">**API Unity comuni**</span><span class="sxs-lookup"><span data-stu-id="cc2b3-138">**Common Unity APIs**</span></span>

    <span data-ttu-id="cc2b3-139">Alcune API Unity, benché utili, possono dare luogo a elevati costi di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-139">Certain Unity APIs, although useful, can be very expensive to execute.</span></span> <span data-ttu-id="cc2b3-140">La maggior parte di esse comporta la ricerca di un elenco corrispondente di GameObject nell'intero grafico della scena.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-140">Most of these involve searching your entire scene graph for some matching list of GameObjects.</span></span> <span data-ttu-id="cc2b3-141">Queste operazioni in genere possono essere evitate memorizzando nella cache i riferimenti o implementando un componente di gestione per i GameObject in questione per tenere traccia dei riferimenti in fase di runtime.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-141">These operations can generally be avoided by caching references or implementing a manager component for the GameObjects in question to track the references at runtime.</span></span>

        GameObject.SendMessage()
        GameObject.BroadcastMessage()
        UnityEngine.Object.Find()
        UnityEngine.Object.FindWithTag()
        UnityEngine.Object.FindObjectOfType()
        UnityEngine.Object.FindObjectsOfType()
        UnityEngine.Object.FindGameObjectsWithTag()
        UnityEngine.Object.FindGameObjectsWithTag()

>[!NOTE]
> <span data-ttu-id="cc2b3-142">*[SendMessage()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* e *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* devono essere eliminate in ogni modo.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-142">*[SendMessage()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* and *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* should be eliminated at all costs.</span></span> <span data-ttu-id="cc2b3-143">Queste funzioni possono essere 1.000 volte più lente rispetto alle chiamate di funzioni dirette.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-143">These functions can be on the order of 1000x slower than direct function calls.</span></span>

3) <span data-ttu-id="cc2b3-144">**Attenzione alla conversione boxing**</span><span class="sxs-lookup"><span data-stu-id="cc2b3-144">**Beware of boxing**</span></span>

    <span data-ttu-id="cc2b3-145">La [conversione boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) è un concetto base del linguaggio e del runtime C#.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-145">[Boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) is a core concept of the C# language and runtime.</span></span> <span data-ttu-id="cc2b3-146">Si tratta del processo di wrapping delle variabili di tipo valore come char, int, bool e così via in variabili di tipo riferimento.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-146">It is the process of wrapping value-typed variables such as char, int, bool, etc. into reference-typed variables.</span></span> <span data-ttu-id="cc2b3-147">Quando una variabile di tipo valore viene "sottoposta alla conversione boxing", viene incapsulata all'interno di un System.Object archiviato nell'heap gestito.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-147">When a value-typed variable is "boxed", it is wrapped inside of a System.Object which is stored on the managed heap.</span></span> <span data-ttu-id="cc2b3-148">Pertanto, la memoria viene allocata e, quando alla fine viene ceduta, deve essere elaborata dal Garbage Collector.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-148">Thus, memory is allocated and eventually when disposed must be processed by the garbage collector.</span></span> <span data-ttu-id="cc2b3-149">Queste allocazioni e deallocazioni comportano un costo in termini di prestazioni e in molti scenari non sono necessarie o possono essere facilmente sostituite da un'alternativa meno dispendiosa.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-149">These allocations and deallocations incur a performance cost and in many scenarios are unnecessary or can be easily replaced by a less expensive alternative.</span></span>

    <span data-ttu-id="cc2b3-150">Una delle forme più comuni di conversione boxing nello sviluppo è l'uso di [tipi di valore nullable](https://docs.microsoft.com//dotnet/csharp/programming-guide/nullable-types/).</span><span class="sxs-lookup"><span data-stu-id="cc2b3-150">One of the most common forms of boxing in development is the use of [nullable value types](https://docs.microsoft.com//dotnet/csharp/programming-guide/nullable-types/).</span></span> <span data-ttu-id="cc2b3-151">Spesso si vuole poter restituire null per un tipo valore in una funzione, soprattutto quando l'operazione potrebbe non riuscire a ottenere il valore.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-151">It is common to want to be able to return null for a value type in a function, especially when the operation may fail trying to get the value.</span></span> <span data-ttu-id="cc2b3-152">Il potenziale problema correlato a questo approccio è rappresentato dal fatto che l'allocazione ora viene eseguita nell'heap e che di conseguenza deve essere sottoposta a Garbage Collection in un secondo momento.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-152">The potential problem with this approach is that allocation now occurs on the heap and consequently needs to be garbage collected later.</span></span>

    <span data-ttu-id="cc2b3-153">**Esempio di conversione boxing in C#**</span><span class="sxs-lookup"><span data-stu-id="cc2b3-153">**Example of boxing in C#**</span></span>

    ```csharp
    // boolean value type is boxed into object boxedMyVar on the heap
    bool myVar = true;
    object boxedMyVar = myVar;
    ```

    <span data-ttu-id="cc2b3-154">**Esempio di conversione boxing problematica tramite tipi valore nullable**</span><span class="sxs-lookup"><span data-stu-id="cc2b3-154">**Example of problematic boxing via nullable value types**</span></span>

    <span data-ttu-id="cc2b3-155">Questo codice illustra una classe di particelle fittizia che è possibile creare in un progetto Unity.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-155">This code demonstrates a dummy particle class that one may create in a Unity project.</span></span> <span data-ttu-id="cc2b3-156">Una chiamata a `TryGetSpeed()` causerà un'allocazione di oggetti nell'heap che dovrà essere sottoposta a Garbage Collection in un momento successivo.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-156">A call to `TryGetSpeed()` will cause object allocation on the heap which will need to be garbage collected at a later point in time.</span></span> <span data-ttu-id="cc2b3-157">Questo esempio è particolarmente problematico perché in una scena possono essere presenti oltre 1000 particelle, a ciascuna delle quali viene chiesta la rispettiva velocità corrente.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-157">This example is particularly problematic as there may be 1000+ or many more particles in a scene, each being asked for their current speed.</span></span> <span data-ttu-id="cc2b3-158">Ciò significa che vengono allocate e conseguentemente deallocate migliaia di oggetti ogni frame, con una notevole riduzione delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-158">Thus, 1000's of objects would be allocated and consequently de-allocated every frame, which would greatly diminish performance.</span></span> <span data-ttu-id="cc2b3-159">La riscrittura della funzione per la restituzione di un valore negativo, ad esempio-1, per indicare un errore consente di evitare questo problema e di mantenere la memoria nello stack.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-159">Re-writing the function to return a negative value such as -1 to indicate a failure would avoid this issue and keep memory on the stack.</span></span>

    ```csharp
        public class MyParticle
        {
            // Example of function returning nullable value type
            public int? TryGetSpeed()
            {
                // Returns current speed int value or null if fails
            }
        }
    ```

#### <a name="repeating-code-paths"></a><span data-ttu-id="cc2b3-160">Percorsi di codice ripetuti</span><span class="sxs-lookup"><span data-stu-id="cc2b3-160">Repeating code paths</span></span>

<span data-ttu-id="cc2b3-161">Le eventuali funzioni di callback Unity ripetute (ovvero</span><span class="sxs-lookup"><span data-stu-id="cc2b3-161">Any repeating Unity callback functions (i.e</span></span> <span data-ttu-id="cc2b3-162">Update) eseguite più volte al secondo e/o ogni frame devono essere scritte con estrema cautela.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-162">Update) that are executed many times per second and/or frame should be written very carefully.</span></span> <span data-ttu-id="cc2b3-163">Tutte le operazioni dispendiose in questo caso avranno un effetto notevole e coerente sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-163">Any expensive operations here will have huge and consistent impact on performance.</span></span>

1) <span data-ttu-id="cc2b3-164">**Funzioni di callback vuote**</span><span class="sxs-lookup"><span data-stu-id="cc2b3-164">**Empty callback functions**</span></span>

    <span data-ttu-id="cc2b3-165">Nonostante il codice seguente possa sembrare innocuo se lasciato nell'applicazione, soprattutto perché tutti gli script Unity si inizializzano automaticamente con tale blocco di codice, questi callback vuoti possono effettivamente diventare molto onerosi.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-165">Although the code below may seem innocent to leave in your application, especially since every Unity script auto-initializes with this code block, these empty callbacks can actually become very expensive.</span></span> <span data-ttu-id="cc2b3-166">Unity opera alternandosi, a fronte di un limite di codice non gestito/gestito, tra il codice UnityEngine e il codice dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-166">Unity operates back and forth over an unmanaged/managed code boundary, between UnityEngine code and your application code.</span></span> <span data-ttu-id="cc2b3-167">Il cambio di contesto su questo bridge è piuttosto costoso, anche se non sono presenti elementi da eseguire.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-167">Context switching over this bridge is fairly expensive, even if there is nothing to execute.</span></span> <span data-ttu-id="cc2b3-168">Ciò diventa particolarmente problematico se la tua app dispone di centinaia di GameObject con componenti che hanno callback Unity ripetuti vuoti.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-168">This becomes especially problematic if your app has 100's of GameObjects with components that have empty repeating Unity callbacks.</span></span>

    ```CS
    void Update()
    {
    }
    ```

>[!NOTE]
> <span data-ttu-id="cc2b3-169">Update() è la manifestazione più comune di questo problema di prestazioni, ma altri callback Unity ripetuti, come quelli riportati di seguito, possono essere ugualmente problematici, se non addirittura peggiori: FixedUpdate(), LateUpdate(), OnPostRender", OnPreRender(), OnRenderImage() e così via.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-169">Update() is the most common manifestation of this performance issue but other repeating Unity callbacks, such as the following can be equally as bad, if not worse: FixedUpdate(), LateUpdate(), OnPostRender", OnPreRender(), OnRenderImage(), etc.</span></span> 

2) <span data-ttu-id="cc2b3-170">**Operazioni per favorire un'unica esecuzione per frame**</span><span class="sxs-lookup"><span data-stu-id="cc2b3-170">**Operations to favor running once per frame**</span></span>

    <span data-ttu-id="cc2b3-171">Le API Unity seguenti sono operazioni comuni per molte app olografiche.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-171">The following Unity APIs are common operations for many Holographic Apps.</span></span> <span data-ttu-id="cc2b3-172">Benché non sia sempre possibile, i risultati di queste funzioni molto spesso possono essere calcolati una sola volta e riutilizzati nell'applicazione per un determinato frame.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-172">Although not always possible, the results from these functions can very commonly be computed once and the results re-utilized across the application for a given frame.</span></span>

    <span data-ttu-id="cc2b3-173">a) È opportuno in genere avere un servizio o una classe singleton dedicata per gestire l'operazione Raycast dello sguardo fisso nella scena e quindi riutilizzare questo risultato in tutti gli altri componenti della scena invece di avere operazioni Raycast ripetute ed essenzialmente identiche eseguite da ogni componente.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-173">a) Generally it is good practice to have a dedicated Singleton class or service to handle your gaze Raycast into the scene and then re-use this result in all other scene components, instead of making repeated and essentially identical Raycast operations by each component.</span></span> <span data-ttu-id="cc2b3-174">Alcune applicazioni naturalmente possono richiedere Raycast da origini diverse o a fronte di [LayerMask](https://docs.unity3d.com/ScriptReference/LayerMask.html) differenti.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-174">Of course, some applications may require raycasts from different origins or against different [LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span></span>

        UnityEngine.Physics.Raycast()
        UnityEngine.Physics.RaycastAll()

    <span data-ttu-id="cc2b3-175">b) Evitare operazioni GetComponent() in callback Unity ripetuti come Update() [memorizzando nella cache i riferimenti](#cache-references) in Start() o Awake()</span><span class="sxs-lookup"><span data-stu-id="cc2b3-175">b) Avoid GetComponent() operations in repeated Unity callbacks like Update() by [caching references](#cache-references) in Start() or Awake()</span></span>

        UnityEngine.Object.GetComponent()

    <span data-ttu-id="cc2b3-176">c) È consigliabile creare un'istanza di tutti gli oggetti, se possibile, in fase di inizializzazione e usare il [pooling di oggetti](#object-pooling) per riciclare e riutilizzare GameObject durante il runtime dell'applicazione</span><span class="sxs-lookup"><span data-stu-id="cc2b3-176">c) It is good practice to instantiate all objects, if possible, at initialization and use [object pooling](#object-pooling) to recycle and re-use GameObjects throughout runtime of your application</span></span>

        UnityEngine.Object.Instantiate()

3) <span data-ttu-id="cc2b3-177">**Evitare le interfacce e i costrutti virtuali**</span><span class="sxs-lookup"><span data-stu-id="cc2b3-177">**Avoid interfaces and virtual constructs**</span></span>

    <span data-ttu-id="cc2b3-178">Il richiamo di chiamate di funzioni tramite le interfacce anziché tramite gli oggetti diretti oppure la chiamata delle funzioni virtuali spesso può essere molto più costosa rispetto all'uso di costrutti diretti o chiamate di funzioni dirette.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-178">Invoking function calls through interfaces vs direct objects or calling virtual functions can often times be much more expensive than utilizing direct constructs or direct function calls.</span></span> <span data-ttu-id="cc2b3-179">Se l'interfaccia o la funzione virtuale non è necessaria, deve essere rimossa.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-179">If the virtual function or interface is unnecessary, then it should be removed.</span></span> <span data-ttu-id="cc2b3-180">Tuttavia, il calo di prestazioni causato dall'uso di questi approcci in genere viene compensato dai vantaggi ottenuti dal punto di vista della semplificazione della collaborazione in fase di sviluppo, della leggibilità e della gestibilità del codice.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-180">However, the performance hit for these approaches are generally worth the trade-off if utilizing them simplifies development collaboration, code readability, and code maintainability.</span></span>

    <span data-ttu-id="cc2b3-181">In genere, è consigliabile non contrassegnare campi e funzioni come virtuali, a meno che non si preveda chiaramente che il membro in questione debba essere sovrascritto.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-181">Generally, the recommendation is to not mark fields and functions as virtual unless there is a clear expectation that this member needs to be overwritten.</span></span> <span data-ttu-id="cc2b3-182">È necessario prestare particolare attenzione ai percorsi di codice ad alta frequenza che vengono chiamati numerose volte per fotogramma o anche una sola volta per fotogramma, ad esempio come nel caso di un metodo `UpdateUI()`.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-182">One should be especially careful around high-frequency code paths that are called many times per frame or even once per frame such as an `UpdateUI()` method.</span></span>

4) <span data-ttu-id="cc2b3-183">**Evitare il passaggio di struct in base al valore**</span><span class="sxs-lookup"><span data-stu-id="cc2b3-183">**Avoid passing structs by value**</span></span>

    <span data-ttu-id="cc2b3-184">Diversamente dalle classi, gli struct sono tipi valore e, quando vengono passati direttamente a una funzione, il relativo contenuto viene copiato in un'istanza appena creata.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-184">Unlike classes, structs are value-types and when passed directly to a function, their contents are copied into a newly created instance.</span></span> <span data-ttu-id="cc2b3-185">Questa copia comporta altri costi in termini di CPU, oltre che di memoria aggiuntiva nello stack.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-185">This copy adds CPU cost, as well as additional memory on the stack.</span></span> <span data-ttu-id="cc2b3-186">Per gli struct di piccole dimensioni, l'effetto è solitamente minimo e quindi accettabile.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-186">For small structs, the effect is usually very minimal and thus acceptable.</span></span> <span data-ttu-id="cc2b3-187">Tuttavia, per le funzioni richiamate ripetutamente a ogni frame e per le funzioni che accettano struct di grandi dimensioni, se possibile, modifica la definizione della funzione in modo che il passaggio avvenga per riferimento.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-187">However, for functions repeatedly invoked every frame as well as functions taking large structs, if possible modify the function definition to pass by reference.</span></span> [<span data-ttu-id="cc2b3-188">Per altre informazioni, vedi qui</span><span class="sxs-lookup"><span data-stu-id="cc2b3-188">Learn more here</span></span>](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/how-to-know-the-difference-passing-a-struct-and-passing-a-class-to-a-method)

#### <a name="miscellaneous"></a><span data-ttu-id="cc2b3-189">Varie</span><span class="sxs-lookup"><span data-stu-id="cc2b3-189">Miscellaneous</span></span>

1) <span data-ttu-id="cc2b3-190">**Fisica**</span><span class="sxs-lookup"><span data-stu-id="cc2b3-190">**Physics**</span></span>

    <span data-ttu-id="cc2b3-191">a) In genere, il modo più semplice per migliorare la fisica consiste nel limitare la quantità di tempo impiegata per la fisica o il numero di iterazioni al secondo.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-191">a) Generally, the easiest way to improve physics is to limit the amount of time spent on Physics or the number of iterations per second.</span></span> <span data-ttu-id="cc2b3-192">Ciò naturalmente ridurrà la precisione della simulazione.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-192">Of course, this will reduce simulation accuracy.</span></span> <span data-ttu-id="cc2b3-193">Vedi [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) in Unity</span><span class="sxs-lookup"><span data-stu-id="cc2b3-193">See [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) in Unity</span></span>

    <span data-ttu-id="cc2b3-194">b) Il tipo di collisori in Unity presenta caratteristiche di prestazioni notevolmente diverse.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-194">b) The type of colliders in Unity have widely different performance characteristics.</span></span> <span data-ttu-id="cc2b3-195">Procedendo da sinistra verso destra, i collisori riportati di seguito vanno da quelli che garantiscono le prestazioni migliori a quelli che forniscono le prestazioni peggiori.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-195">The order below lists the most performant colliders to least performant colliders from left to right.</span></span> <span data-ttu-id="cc2b3-196">È estremamente importante evitare i collisori di tipo Mesh, che sono sostanzialmente più costosi rispetto ai collisori primitivi.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-196">It is most important to avoid Mesh Colliders, which are substantially more expensive than the primitive colliders.</span></span>

        Sphere < Capsule < Box <<< Mesh (Convex) < Mesh (non-Convex)

    <span data-ttu-id="cc2b3-197">Per altre informazioni, vedi [Unity Physics Best Practices](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) (Procedure consigliate per la fisica in Unity)</span><span class="sxs-lookup"><span data-stu-id="cc2b3-197">See [Unity Physics Best Practices](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) for more info</span></span>

2) <span data-ttu-id="cc2b3-198">**Animazioni**</span><span class="sxs-lookup"><span data-stu-id="cc2b3-198">**Animations**</span></span>

    <span data-ttu-id="cc2b3-199">Disabilita le animazioni inattive disabilitando il componente Animator (Animatore); la disabilitazione dell'oggetto gioco non avrà lo stesso effetto.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-199">Disable idle animations by disabling the Animator component (disabling the game object won't have the same effect).</span></span> <span data-ttu-id="cc2b3-200">Evita i modelli di progettazione in cui un animatore si trova in un ciclo che imposta un valore sullo stesso elemento.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-200">Avoid design patterns where an animator sits in a loop setting a value to the same thing.</span></span> <span data-ttu-id="cc2b3-201">Per questa tecnica si verifica un notevole overhead, senza alcun effetto sull'applicazione.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-201">There is considerable overhead for this technique, with no effect on the application.</span></span> [<span data-ttu-id="cc2b3-202">Per altre informazioni, vedi qui.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-202">Learn more here.</span></span>](https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html)

3) <span data-ttu-id="cc2b3-203">**Algoritmi complessi**</span><span class="sxs-lookup"><span data-stu-id="cc2b3-203">**Complex algorithms**</span></span>

    <span data-ttu-id="cc2b3-204">Se l'applicazione usa algoritmi complessi, ad esempio per cinematica inversa, ricerca di percorsi e così via, cerca un approccio più semplice o modifica le impostazioni pertinenti per le relative prestazioni</span><span class="sxs-lookup"><span data-stu-id="cc2b3-204">If your application is using complex algorithms such as inverse kinematics, path finding, etc, look to find a simpler approach or adjust relevant settings for their performance</span></span>

## <a name="cpu-to-gpu-performance-recommendations"></a><span data-ttu-id="cc2b3-205">Consigli sulle prestazioni della CPU in relazione alla GPU</span><span class="sxs-lookup"><span data-stu-id="cc2b3-205">CPU-to-GPU performance recommendations</span></span>

<span data-ttu-id="cc2b3-206">In genere, le prestazioni della CPU in relazione alla GPU si basano sulle **chiamate di disegno** inviate alla scheda grafica.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-206">Generally, CPU-to-GPU performance comes down to the **draw calls** submitted to the graphics card.</span></span> <span data-ttu-id="cc2b3-207">Per migliorare le prestazioni, tali chiamate devono essere strategicamente **a) ridotte** o **b) ristrutturate** per risultati ottimali.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-207">To improve performance, draw calls need to be strategically **a) reduced** or **b) restructured** for optimal results.</span></span> <span data-ttu-id="cc2b3-208">Poiché le chiamate di disegno di per sé sono a elevato utilizzo di risorse, la loro riduzione comporterà una riduzione del lavoro complessivo richiesto.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-208">Since draw calls themselves are resource-intensive, reducing them will reduce overall work required.</span></span> <span data-ttu-id="cc2b3-209">Inoltre, i cambiamenti di stato tra una chiamata di disegno e l'altra richiedono costose operazioni di convalida e conversione nel driver di grafica. Pertanto, la ristrutturazione delle chiamate di disegno dell'applicazione per limitare i cambiamenti di stato (ad esempio,</span><span class="sxs-lookup"><span data-stu-id="cc2b3-209">Further, state changes between draw calls requires costly validation and translation steps in the graphics driver and thus, restructuring of your application's draw calls to limit state changes (i.e</span></span> <span data-ttu-id="cc2b3-210">il passaggio da un materiale all'altro e così via) può migliorare le prestazioni.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-210">different materials, etc) can boost performance.</span></span>

<span data-ttu-id="cc2b3-211">Unity offre un interessante articolo che fornisce una panoramica sull'invio delle chiamate di disegno in batch per la propria piattaforma.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-211">Unity has a great article that gives an overview and dives into batching draw calls for their platform.</span></span>
- <span data-ttu-id="cc2b3-212">[Unity Draw Call Batching](https://docs.unity3d.com/Manual/DrawCallBatching.html) (Invio delle chiamate di disegno in batch in Unity)</span><span class="sxs-lookup"><span data-stu-id="cc2b3-212">[Unity Draw Call Batching](https://docs.unity3d.com/Manual/DrawCallBatching.html)</span></span>

#### <a name="single-pass-instanced-rendering"></a><span data-ttu-id="cc2b3-213">Rendering con istanze a singolo passaggio</span><span class="sxs-lookup"><span data-stu-id="cc2b3-213">Single pass instanced rendering</span></span>

<span data-ttu-id="cc2b3-214">Il rendering con istanze a singolo passaggio in Unity consente di ridurre le chiamate di disegno per ogni occhio a un'unica chiamata di disegno con istanza.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-214">Single Pass Instanced Rendering in Unity allows for draw calls for each eye to be reduced down to one instanced draw call.</span></span> <span data-ttu-id="cc2b3-215">A causa della coerenza della cache tra due chiamate di disegno, si verifica anche un certo miglioramento delle prestazioni per la GPU.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-215">Due to cache coherency between two draw calls, there is also some performance improvement on the GPU as well.</span></span>

<span data-ttu-id="cc2b3-216">Per abilitare questa funzionalità nel tuo progetto Unity</span><span class="sxs-lookup"><span data-stu-id="cc2b3-216">To enable this feature in your Unity Project</span></span>
1)  <span data-ttu-id="cc2b3-217">Apri **Player XR Settings** (Impostazioni XR riproduttore). A tale scopo, vai a **Edit** (Modifica) > **Project Settings** (Impostazioni progetto) > **Player** (Riproduttore) > **XR Settings** (Impostazioni XR)</span><span class="sxs-lookup"><span data-stu-id="cc2b3-217">Open **Player XR Settings** (go to **Edit** > **Project Settings** > **Player** > **XR Settings**)</span></span>
2) <span data-ttu-id="cc2b3-218">Scegli **Single Pass Instanced** (Con istanze a singolo passaggio) dal menu a discesa **Stereo Rendering Method** (Metodo di rendering stereo). Deve essere selezionata la casella di controllo **Virtual Reality Supported** (Realtà virtuale supportata)</span><span class="sxs-lookup"><span data-stu-id="cc2b3-218">Select **Single Pass Instanced** from the **Stereo Rendering Method** drop-down menu (**Virtual Reality Supported** checkbox must be checked)</span></span>

<span data-ttu-id="cc2b3-219">Per i dettagli su questo approccio di rendering, leggi gli articoli seguenti.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-219">Read the following articles from Unity for details with this rendering approach.</span></span>
- <span data-ttu-id="cc2b3-220">[How to maximize AR and VR performance with advanced stereo rendering](https://blogs.unity3d.com/2017/11/21/how-to-maximize-ar-and-vr-performance-with-advanced-stereo-rendering/) (Come ottimizzare le prestazioni di AR e VR con il rendering stereo avanzato)</span><span class="sxs-lookup"><span data-stu-id="cc2b3-220">[How to maximize AR and VR performance with advanced stereo rendering](https://blogs.unity3d.com/2017/11/21/how-to-maximize-ar-and-vr-performance-with-advanced-stereo-rendering/)</span></span>
- <span data-ttu-id="cc2b3-221">[Single Pass Instancing](https://docs.unity3d.com/Manual/SinglePassInstancing.html) (Creazione di istanze a singolo passaggio)</span><span class="sxs-lookup"><span data-stu-id="cc2b3-221">[Single Pass Instancing](https://docs.unity3d.com/Manual/SinglePassInstancing.html)</span></span> 

>[!NOTE]
> <span data-ttu-id="cc2b3-222">Un problema comune relativo al rendering con istanze a singolo passaggio si verifica se gli sviluppatori dispongono già di shader personalizzati non scritti per la creazione di istanze.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-222">One common issue with Single Pass Instanced Rendering occurs if developers already have existing custom shaders not written for instancing.</span></span> <span data-ttu-id="cc2b3-223">Dopo l'abilitazione di questa funzionalità, gli sviluppatori possono notare che per alcuni GameObject viene eseguito il rendering in un solo occhio.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-223">After enabling this feature, developers may notice some GameObjects only render in one eye.</span></span> <span data-ttu-id="cc2b3-224">Ciò è dovuto al fatto che gli shader personalizzati associati non hanno le proprietà appropriate per la creazione di istanze.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-224">This is because the associated custom shaders do not have the appropriate properties for instancing.</span></span>
>
> <span data-ttu-id="cc2b3-225">Per informazioni su come risolvere questo problema, vedi l'articolo di Unity [Single Pass Stereo Rendering for HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) (Rendering stereo a singolo passaggio per HoloLens)</span><span class="sxs-lookup"><span data-stu-id="cc2b3-225">See [Single Pass Stereo Rendering for HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) from Unity for how to address this problem</span></span>

#### <a name="static-batching"></a><span data-ttu-id="cc2b3-226">Invio in batch statico</span><span class="sxs-lookup"><span data-stu-id="cc2b3-226">Static batching</span></span>

<span data-ttu-id="cc2b3-227">Unity è in grado di inviare in batch numerosi oggetti statici per ridurre le chiamate di disegno alla GPU.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-227">Unity is able to batch many static objects to reduce draw calls to the GPU.</span></span> <span data-ttu-id="cc2b3-228">L'invio in batch statico funziona per la maggior degli oggetti [Renderer](https://docs.unity3d.com/ScriptReference/Renderer.html) in Unity che **1) condividono lo stesso materiale** e **2) sono tutti contrassegnati come *statici*** (seleziona un oggetto in Unity e seleziona la casella di controllo nell'angolo superiore destro della finestra Inspector (Controllo)).</span><span class="sxs-lookup"><span data-stu-id="cc2b3-228">Static Batching works for most [Renderer](https://docs.unity3d.com/ScriptReference/Renderer.html) objects in Unity that **1) share the same material** and **2) are all marked as *Static*** (Select an object in Unity and click the checkbox in the top right of the inspector).</span></span> <span data-ttu-id="cc2b3-229">I GameObject contrassegnati come *statici* non possono essere spostati per l'intero runtime dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-229">GameObjects marked as *Static* cannot be moved throughout your application's runtime.</span></span> <span data-ttu-id="cc2b3-230">Può risultare pertanto difficile sfruttare l'invio in batch statico su HoloLens, dove virtualmente tutti gli oggetti devono essere posizionati, spostati, ridimensionati e così via. Per i visori VR immersive, l'invio in batch statico può ridurre in modo significativo le chiamate di disegno e quindi migliorare le prestazioni.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-230">Thus, static batching can be difficult to leverage on HoloLens where virtually every object needs to be placed, moved, scaled, etc. For immersive headsets, static batching can dramatically reduce draw calls and thus improve performance.</span></span>

<span data-ttu-id="cc2b3-231">Per altri dettagli, leggi *Static Batching* (Invio in batch statico) in [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) (Invio di chiamate di disegno in batch in Unity).</span><span class="sxs-lookup"><span data-stu-id="cc2b3-231">Read *Static Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for more details.</span></span>

#### <a name="dynamic-batching"></a><span data-ttu-id="cc2b3-232">Invio in batch dinamico</span><span class="sxs-lookup"><span data-stu-id="cc2b3-232">Dynamic batching</span></span>

<span data-ttu-id="cc2b3-233">Poiché è problematico contrassegnare gli oggetti come *statici* per lo sviluppo per HoloLens, l'invio in batch dinamico può essere un'ottima soluzione per compensare la carenza di questa funzionalità.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-233">Since it is problematic to mark objects as *Static* for HoloLens development, dynamic batching can be a great tool to compensate for this lacking feature.</span></span> <span data-ttu-id="cc2b3-234">Può naturalmente essere utile anche nei visori VR immersive.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-234">Of course, it can also be useful on immersive headsets, as well.</span></span> <span data-ttu-id="cc2b3-235">Può tuttavia essere difficile abilitare l'invio in batch dinamico in Unity perché i GameObject devono **a) condividere lo stesso materiale** e **b) soddisfare un lungo elenco di altri criteri**.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-235">However, dynamic batching in Unity can be difficult to enable because GameObjects must **a) share the same Material** and **b) meet a long list of other criteria**.</span></span>

<span data-ttu-id="cc2b3-236">Per l'elenco completo, leggi *Dynamic Batching* (Invio in batch dinamico) in [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) (Invio di chiamate di disegno in batch in Unity).</span><span class="sxs-lookup"><span data-stu-id="cc2b3-236">Read *Dynamic Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for the full list.</span></span> <span data-ttu-id="cc2b3-237">In genere, i GameObject diventano non validi per l'invio in batch dinamico perché i dati di mesh associati non possono essere più di 300 vertici.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-237">Most commonly, GameObjects become invalid to be batched dynamically, because the associated mesh data can be no more than 300 vertices.</span></span>

#### <a name="other-techniques"></a><span data-ttu-id="cc2b3-238">Altre tecniche</span><span class="sxs-lookup"><span data-stu-id="cc2b3-238">Other techniques</span></span>

<span data-ttu-id="cc2b3-239">L'invio in batch può avere luogo solo se più GameObject sono in grado di condividere lo stesso materiale.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-239">Batching can only occur if multiple GameObjects are able to share the same material.</span></span> <span data-ttu-id="cc2b3-240">Questa operazione generalmente verrà impedita dal fatto che i GameObject devono avere una trama univoca per il rispettivo materiale.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-240">Typically, this will be blocked by the need for GameObjects to have a unique texture for their respective Material.</span></span> <span data-ttu-id="cc2b3-241">È pratica comune combinare le trame in un'unica trama più grande, un metodo noto come [creazione di un atlante delle trame](https://en.wikipedia.org/wiki/Texture_atlas).</span><span class="sxs-lookup"><span data-stu-id="cc2b3-241">It is common to combine Textures into one big Texture, a method known as [Texture Atlasing](https://en.wikipedia.org/wiki/Texture_atlas).</span></span>

<span data-ttu-id="cc2b3-242">Inoltre, di solito è preferibile combinare le mesh in un GameObject, ove possibile e ragionevole.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-242">Furthermore, it is generally preferable to combine meshes into one GameObject where possible and reasonable.</span></span> <span data-ttu-id="cc2b3-243">Ogni renderer in Unity avrà associate le proprie chiamate di disegno rispetto all'invio di una mesh combinata facente capo a un solo renderer.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-243">Each Renderer in Unity will have its associated draw call(s) versus submitting a combined mesh under one Renderer.</span></span>

>[!NOTE]
> <span data-ttu-id="cc2b3-244">Se si modificano le proprietà di Renderer.material in fase di runtime, verrà creata una copia del materiale e, di conseguenza, potenzialmente si interromperà il batch.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-244">Modifying properties of Renderer.material at runtime will create a copy of the Material and thus potentially break batching.</span></span> <span data-ttu-id="cc2b3-245">Usa Renderer.sharedMaterial per modificare le proprietà di materiale condivise tra GameObject.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-245">Use Renderer.sharedMaterial to modify shared material properties across GameObjects.</span></span>

## <a name="gpu-performance-recommendations"></a><span data-ttu-id="cc2b3-246">Consigli sulle prestazioni della GPU</span><span class="sxs-lookup"><span data-stu-id="cc2b3-246">GPU performance recommendations</span></span>

<span data-ttu-id="cc2b3-247">Scopri di più sull'[ottimizzazione del rendering della grafica in Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span><span class="sxs-lookup"><span data-stu-id="cc2b3-247">Learn more about [optimizing graphics rendering in Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span></span>

### <a name="optimize-depth-buffer-sharing"></a><span data-ttu-id="cc2b3-248">Ottimizzare la condivisione buffer di intensità</span><span class="sxs-lookup"><span data-stu-id="cc2b3-248">Optimize depth buffer sharing</span></span>

<span data-ttu-id="cc2b3-249">È in genere consigliabile abilitare **Depth buffer sharing** (Condivisione buffer di intensità) in **Player XR Settings** (Impostazioni XR riproduttore) ai fini dell'ottimizzazione per la [stabilità degli ologrammi](Hologram-stability.md).</span><span class="sxs-lookup"><span data-stu-id="cc2b3-249">It is generally recommended to enable **Depth buffer sharing** under **Player XR Settings** to optimize for [hologram stability](Hologram-stability.md).</span></span> <span data-ttu-id="cc2b3-250">Se però con questa impostazione viene abilitata la riproiezione in fase avanzata basata sull'intensità, è opportuno selezionare **16-bit depth format** (Formato con intensità a 16 bit) anziché **24-bit depth format** (Formato con intensità a 24 bit).</span><span class="sxs-lookup"><span data-stu-id="cc2b3-250">When enabling depth-based late-stage reprojection with this setting however, it is recommended to select **16-bit depth format** instead of **24-bit depth format**.</span></span> <span data-ttu-id="cc2b3-251">I buffer di intensità a 16 bit ridurranno in modo significativo la larghezza di banda (e quindi la potenza) associata al traffico di buffer di intensità.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-251">The 16-bit depth buffers will drastically reduce the bandwidth (and thus power) associated with depth buffer traffic.</span></span> <span data-ttu-id="cc2b3-252">Questo può essere un ottimo risultato sia in termini di riduzione della potenza che di miglioramento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-252">This can be a big win both in power reduction and performance improvement.</span></span> <span data-ttu-id="cc2b3-253">Tuttavia, quando viene usata l'impostazione *16-bit depth format* (Formato con intensità a 16 bit), sono possibili due risultati negativi.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-253">However, there are two possible negative outcomes by using *16-bit depth format*.</span></span>

<span data-ttu-id="cc2b3-254">**Z-fighting**</span><span class="sxs-lookup"><span data-stu-id="cc2b3-254">**Z-Fighting**</span></span>

<span data-ttu-id="cc2b3-255">La fedeltà dell'intervallo di intensità inferiore rende più probabile il verificarsi dell'effetto [z-fighting](https://en.wikipedia.org/wiki/Z-fighting) con 16 bit piuttosto che con 24 bit.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-255">The reduced depth range fidelity makes [z-fighting](https://en.wikipedia.org/wiki/Z-fighting) more likely to occur with 16-bit than 24-bit.</span></span> <span data-ttu-id="cc2b3-256">Per evitare questi artefatti, modifica i piani di ritaglio vicini/lontani della [camera Unity](https://docs.unity3d.com/Manual/class-Camera.html) in modo da tenere conto della minore precisione.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-256">To avoid these artifacts, modify the near/far clip planes of the [Unity camera](https://docs.unity3d.com/Manual/class-Camera.html) to account for the lower precision.</span></span> <span data-ttu-id="cc2b3-257">Per le applicazioni basate su HoloLens, un piano di ritaglio lontano di 50 m, al posto dei 1000 m predefiniti di Unity, in genere consente di eliminare l'effetto z-fighting.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-257">For HoloLens-based applications, a far clip plane of 50m instead of the Unity default 1000m can generally eliminate any z-fighting.</span></span>

<span data-ttu-id="cc2b3-258">**Buffer degli stencil disabilitato**</span><span class="sxs-lookup"><span data-stu-id="cc2b3-258">**Disabled Stencil Buffer**</span></span>

<span data-ttu-id="cc2b3-259">Quando Unity crea una [trama di rendering con intensità a 16 bit](https://docs.unity3d.com/ScriptReference/RenderTexture-depth.html), non viene creato alcun buffer degli stencil.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-259">When Unity creates a [Render Texture with 16-bit depth](https://docs.unity3d.com/ScriptReference/RenderTexture-depth.html), there is no stencil buffer created.</span></span> <span data-ttu-id="cc2b3-260">Se si seleziona 24-bit depth format (Formato con intensità a 24 bit), come indicato nella documentazione di Unity, verrà creato un buffer z a 24 bit, insieme a un [buffer degli stencil a 8 bit] (https://docs.unity3d.com/Manual/SL-Stencil.html) (se i 32 bit sono applicabili su un dispositivo, com'è in genere il caso su HoloLens).</span><span class="sxs-lookup"><span data-stu-id="cc2b3-260">Selecting 24-bit depth format, per Unity documentation, will create a 24-bit z-buffer, as well as an [8-bit stencil buffer] (https://docs.unity3d.com/Manual/SL-Stencil.html) (if 32-bit is applicable on a device, which is generally the case such as HoloLens).</span></span>

### <a name="avoid-full-screen-effects"></a><span data-ttu-id="cc2b3-261">Evitare effetti a schermo intero</span><span class="sxs-lookup"><span data-stu-id="cc2b3-261">Avoid full-screen effects</span></span>

<span data-ttu-id="cc2b3-262">Le tecniche che agiscono sull'intero schermo possono essere piuttosto onerose perché il loro ordine di grandezza è di milioni di operazioni ogni frame.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-262">Techniques that operate on the full screen can be quite expensive since their order of magnitude is millions of operations every frame.</span></span> <span data-ttu-id="cc2b3-263">È quindi consigliabile evitare [effetti di post-elaborazione](https://docs.unity3d.com/Manual/PostProcessingOverview.html), tra cui ad esempio l'anti-aliasing, l'effetto bloom e altro ancora.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-263">Thus, it is recommended to avoid [post-processing effects](https://docs.unity3d.com/Manual/PostProcessingOverview.html) such as anti-aliasing, bloom, and more.</span></span>

### <a name="optimal-lighting-settings"></a><span data-ttu-id="cc2b3-264">Impostazioni ottimali dell'illuminazione</span><span class="sxs-lookup"><span data-stu-id="cc2b3-264">Optimal lighting settings</span></span>

<span data-ttu-id="cc2b3-265">La funzionalità [Real-time Global Illumination](https://docs.unity3d.com/Manual/GIIntro.html) (Illuminazione globale in tempo reale) in Unity può fornire risultati visivi sorprendenti, ma comporta calcoli per l'illuminazione piuttosto onerosi.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-265">[Real-time Global Illumination](https://docs.unity3d.com/Manual/GIIntro.html) in Unity can provide outstanding visual results but involves quite expensive lighting calculations.</span></span> <span data-ttu-id="cc2b3-266">È consigliabile disabilitare questa funzionalità per ogni file della scena Unity tramite **Window** (Finestra) > **Rendering** > Lighting Settings **(Impostazioni illuminazione)** > Deseleziona **Real-time Global Illumination** (Illuminazione globale in tempo reale).</span><span class="sxs-lookup"><span data-stu-id="cc2b3-266">It is recommended to disable Realtime Global Illumination for every Unity scene file via **Window** > **Rendering** > **Lighting Settings** > Uncheck **Real-time Global Illumination**.</span></span>

<span data-ttu-id="cc2b3-267">È inoltre consigliabile disabilitare tutte le ombreggiature perché anche queste aggiungono passaggi di GPU dispendiosi nella scena Unity.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-267">Furthermore, it is recommended to disable all shadow casting as these also add expensive GPU passes onto a Unity scene.</span></span> <span data-ttu-id="cc2b3-268">Le ombreggiature possono essere disabilitate per la singola luce, ma possono anche essere controllate in modo olistico tramite le impostazioni relative alla qualità.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-268">Shadows can be disable per light but can also be controlled holistically via Quality settings.</span></span>

<span data-ttu-id="cc2b3-269">**Edit** (Modifica)  > **Project Settings** (Impostazioni progetto) e quindi seleziona la categoria **Quality** (Qualità) > Seleziona **Low Quality** (Qualità bassa) per la piattaforma UWP.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-269">**Edit** > **Project Settings**, then select the **Quality** category > Select **Low Quality** for the UWP Platform.</span></span> <span data-ttu-id="cc2b3-270">È anche sufficiente impostare la proprietà **Shadows** (Ombreggiature) su **Disable Shadows** (Disabilita ombreggiature).</span><span class="sxs-lookup"><span data-stu-id="cc2b3-270">One can also just set the **Shadows** property to **Disable Shadows**.</span></span>

### <a name="reduce-poly-count"></a><span data-ttu-id="cc2b3-271">Ridurre il numero dei poligoni</span><span class="sxs-lookup"><span data-stu-id="cc2b3-271">Reduce poly count</span></span>

<span data-ttu-id="cc2b3-272">Il numero dei poligoni in genere viene ridotto tramite</span><span class="sxs-lookup"><span data-stu-id="cc2b3-272">Polygon count is usually reduced by either</span></span>
1) <span data-ttu-id="cc2b3-273">Rimozione di oggetti da una scena</span><span class="sxs-lookup"><span data-stu-id="cc2b3-273">Removing objects from a scene</span></span>
2) <span data-ttu-id="cc2b3-274">Decimazione degli asset, che riduce il numero di poligoni per una determinata mesh</span><span class="sxs-lookup"><span data-stu-id="cc2b3-274">Asset decimation which reduces the number of polygons for a given mesh</span></span>
3) <span data-ttu-id="cc2b3-275">Implementazione, nell'applicazione, di un [sistema LOD (Level of Detail)](https://docs.unity3d.com/Manual/LevelOfDetail.html) che esegue il rendering degli oggetti lontani con una versione costituita da meno poligoni della stessa geometria</span><span class="sxs-lookup"><span data-stu-id="cc2b3-275">Implementing a [Level of Detail (LOD) System](https://docs.unity3d.com/Manual/LevelOfDetail.html) into your application which renders far away objects with lower-polygon version of the same geometry</span></span>

### <a name="understanding-shaders-in-unity"></a><span data-ttu-id="cc2b3-276">Informazioni sugli shader in Unity</span><span class="sxs-lookup"><span data-stu-id="cc2b3-276">Understanding shaders in Unity</span></span>

<span data-ttu-id="cc2b3-277">Una semplice approssimazione per confrontare gli shader in termini di prestazioni consiste nell'identificare il numero medio di operazioni eseguite da ognuno di essi in fase di runtime.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-277">An easy approximation to compare shaders in performance is to identify the average number of operations each executes at runtime.</span></span> <span data-ttu-id="cc2b3-278">Questa attività può essere effettuata facilmente in Unity.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-278">This can be done easily in Unity.</span></span>

1) <span data-ttu-id="cc2b3-279">Seleziona l'asset dello shader oppure seleziona un materiale e quindi nell'angolo superiore destro della finestra Inspector (Controllo) fai clic sull'icona a forma di ingranaggio e su **"Select Shader"** (Seleziona shader)</span><span class="sxs-lookup"><span data-stu-id="cc2b3-279">Select your shader asset or select a material, then in the top right corner of the inspector window, select the gear icon followed by **"Select Shader"**</span></span>

    ![Selezione dello shader in Unity](images/Select-shader-unity.png)
2) <span data-ttu-id="cc2b3-281">Con l'asset dello shader selezionato, fai clic sul pulsante **"Compile and show code"** (Compila e mostra il codice) nella finestra Inspector (Controllo)</span><span class="sxs-lookup"><span data-stu-id="cc2b3-281">With the shader asset selected, click the **"Compile and show code"** button under the inspector window</span></span>

    ![Compilazione del codice dello shader in Unity](images/compile-shader-code-unity.PNG)

3) <span data-ttu-id="cc2b3-283">Dopo la compilazione, cerca nei risultati la sezione delle statistiche con il numero di diverse operazioni per il vertex shader e per il pixel shader (Nota: i pixel shader spesso vengono indicati anche come shader di frammento)</span><span class="sxs-lookup"><span data-stu-id="cc2b3-283">After compiling, look for the statistics section in the results with the number of different operations for both the vertex and pixel shader (Note: pixel shaders are often also called fragment shaders)</span></span>

    ![Operazioni degli shader standard di Unity](images/unity-standard-shader-compilation.png)

#### <a name="optimize-pixel-shaders"></a><span data-ttu-id="cc2b3-285">Ottimizzare i pixel shader</span><span class="sxs-lookup"><span data-stu-id="cc2b3-285">Optimize pixel shaders</span></span>

<span data-ttu-id="cc2b3-286">Esaminando i risultati statistici compilati con il metodo sopra descritto, lo [ shader di frammento](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) eseguirà in genere più operazioni rispetto al [vertex shader](https://en.wikipedia.org/wiki/Shader#Vertex_shaders) in media.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-286">Looking at the compiled statistic results using the method above, the [fragment shader](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) will generally execute more operations than the [vertex shader](https://en.wikipedia.org/wiki/Shader#Vertex_shaders), on average.</span></span> <span data-ttu-id="cc2b3-287">Lo shader di frammento (noto anche come pixel shader) viene eseguito per pixel nell'output su schermo, mentre il vertex shader viene eseguito solo per vertice di tutte le mesh disegnate sullo schermo.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-287">The fragment shader, also known as the pixel shader, is executed per pixel on the screen output while the vertex shader is only executed per-vertex of all meshes being drawn to the screen.</span></span> 

<span data-ttu-id="cc2b3-288">Pertanto, oltre ad avere più istruzioni rispetto ai vertex shader a causa di tutti i calcoli per l'illuminazione, gli shader di frammento vengono quasi sempre eseguiti su un set di dati più grande.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-288">Thus, not only do fragment shaders have more instructions than vertex shaders because of all the lighting calculations, fragment shaders are almost always executed on a larger dataset.</span></span> <span data-ttu-id="cc2b3-289">Ad esempio, se l'output su schermo è un'immagine 2 K per 2 K, lo shader di frammento può venire eseguito 2000\*2000 = 4 milioni di volte.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-289">For example, if the screen output is a 2k by 2k image, then the fragment shader can get executed 2,000\*2,000 = 4,000,000 times.</span></span> <span data-ttu-id="cc2b3-290">Se viene eseguito il rendering di due occhi, questo numero raddoppia perché le schermate sono due.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-290">If rendering two eyes, this number doubles since there are two screens.</span></span> <span data-ttu-id="cc2b3-291">Se un'applicazione di realtà mista prevede più passaggi, effetti di post-elaborazione a schermo intero o il rendering di più mesh sullo stesso pixel, questo numero aumenterà in modo considerevole.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-291">If a mixed reality application has multiple passes, full-screen post-processing effects, or rendering multiple meshes to the same pixel, this number will increase dramatically.</span></span> 

<span data-ttu-id="cc2b3-292">Perciò, la riduzione del numero di operazioni nello shader di frammento può in genere assicurare un miglioramento delle prestazioni notevolmente superiore rispetto alle ottimizzazioni nel vertex shader.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-292">Therefore, reducing the number of operations in the fragment shader can generally give far greater performance gains over optimizations in the vertex shader.</span></span>

#### <a name="unity-standard-shader-alternatives"></a><span data-ttu-id="cc2b3-293">Alternative agli shader standard di Unity</span><span class="sxs-lookup"><span data-stu-id="cc2b3-293">Unity Standard shader alternatives</span></span>

<span data-ttu-id="cc2b3-294">Invece di usare un rendering fisico (PBR, Physically Based Rendering) o un altro shader di alta qualità, cerca di usare uno shader più efficiente e più economico.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-294">Instead of using a physically based rendering (PBR) or another high-quality shader, look at utilizing a more performant and cheaper shader.</span></span> <span data-ttu-id="cc2b3-295">[Mixed Reality Toolkit](https://github.com/Microsoft/MixedRealityToolkit-Unity) offre lo [shader standard MRTK](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) che è stato ottimizzato per i progetti di realtà mista.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-295">The [Mixed Reality Toolkit](https://github.com/Microsoft/MixedRealityToolkit-Unity) provides the [MRTK standard shader](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) that has been optimized for mixed reality projects.</span></span>

<span data-ttu-id="cc2b3-296">Unity inoltre offre shader senza illuminazione, con illuminazione dei vertici, diffusi e altre opzioni di shader semplificati che sono molto più veloci dello shader standard di Unity.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-296">Unity also provides an unlit, vertex lit, diffuse, and other simplified shader options that are significantly faster compared to the Unity Standard shader.</span></span> <span data-ttu-id="cc2b3-297">Per informazioni più dettagliate, vedi [Usage and Performance of Built-in Shaders](https://docs.unity3d.com/Manual/shader-Performance.html) (Utilizzo e prestazioni degli shader incorporati).</span><span class="sxs-lookup"><span data-stu-id="cc2b3-297">See [Usage and Performance of Built-in Shaders](https://docs.unity3d.com/Manual/shader-Performance.html) for more detailed information.</span></span>

#### <a name="shader-preloading"></a><span data-ttu-id="cc2b3-298">Precaricamento degli shader</span><span class="sxs-lookup"><span data-stu-id="cc2b3-298">Shader preloading</span></span>

<span data-ttu-id="cc2b3-299">Usa il *precaricamento dello shader* e altri trucchi per ottimizzare il [tempo di caricamento degli shader](https://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span><span class="sxs-lookup"><span data-stu-id="cc2b3-299">Use *Shader preloading* and other tricks to optimize [shader load time](https://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span></span> <span data-ttu-id="cc2b3-300">In particolare, con il precaricamento non si verificheranno problemi di blocco dovuti alla compilazione dello shader in fase di runtime.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-300">In particular, shader preloading means you won't see any hitches due to runtime shader compilation.</span></span>

### <a name="limit-overdraw"></a><span data-ttu-id="cc2b3-301">Limitare le sovrapposizioni</span><span class="sxs-lookup"><span data-stu-id="cc2b3-301">Limit overdraw</span></span>

<span data-ttu-id="cc2b3-302">In Unity è possibile visualizzare le sovrapposizioni per la scena attivando il [**menu della modalità di disegno**](https://docs.unity3d.com/Manual/ViewModes.html) nell'angolo superiore sinistro della **vista Scene** (Scena) e scegliendo **Overdraw** (Sovrapposizione).</span><span class="sxs-lookup"><span data-stu-id="cc2b3-302">In Unity, one can display overdraw for their scene, by toggling the [**draw mode menu**](https://docs.unity3d.com/Manual/ViewModes.html) in the top-left corner of the **Scene view** and selecting **Overdraw**.</span></span>

<span data-ttu-id="cc2b3-303">In genere è possibile ridurre le sovrapposizioni eseguendo il culling degli oggetti prima che vengano inviati alla GPU.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-303">Generally, overdraw can be mitigated by culling objects ahead of time before they are sent to the GPU.</span></span> <span data-ttu-id="cc2b3-304">Unity fornisce i dettagli sull'implementazione del [culling di occlusione](https://docs.unity3d.com/Manual/OcclusionCulling.html) per il proprio motore.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-304">Unity provides details on implementing [Occlusion Culling](https://docs.unity3d.com/Manual/OcclusionCulling.html) for their engine.</span></span>

## <a name="memory-recommendations"></a><span data-ttu-id="cc2b3-305">Consigli sulla memoria</span><span class="sxs-lookup"><span data-stu-id="cc2b3-305">Memory recommendations</span></span>

<span data-ttu-id="cc2b3-306">Un numero eccessivo di operazioni di allocazione e deallocazione può avere effetti negativi sull'applicazione olografica, causando prestazioni non coerenti, frame bloccati e altri comportamenti indesiderati.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-306">Excessive memory allocation & deallocation operations can have adverse effects on your holographic application, resulting in inconsistent performance, frozen frames, and other detrimental behavior.</span></span> <span data-ttu-id="cc2b3-307">È particolarmente importante comprendere le considerazioni relative alla memoria durante le attività di sviluppo in Unity perché la gestione della memoria è controllata dal Garbage Collector.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-307">It is especially important to understand memory considerations when developing in Unity since memory management is controlled by the garbage collector.</span></span>

#### <a name="garbage-collection"></a><span data-ttu-id="cc2b3-308">Garbage Collection</span><span class="sxs-lookup"><span data-stu-id="cc2b3-308">Garbage collection</span></span>

<span data-ttu-id="cc2b3-309">Le app olografiche perderanno il tempo di calcolo dell'elaborazione per il Garbage Collector (GC) quando questo viene attivato per analizzare gli oggetti che non sono più nell'ambito durante l'esecuzione e la relativa memoria deve essere rilasciata per poter essere disponibile per il riutilizzo.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-309">Holographic apps will lose processing compute time to the garbage collector (GC) when the GC is activated to analyze objects that are no longer in scope during execution and their memory needs to be released, so it can be made available for re-use.</span></span> <span data-ttu-id="cc2b3-310">Con allocazioni e deallocazioni costanti, in genere il Garbage Collector deve essere eseguito più frequentemente, con ripercussioni negative sulle prestazioni e sull'esperienza utente.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-310">Constant allocations and de-allocations will generally require the garbage collector to run more frequently, thus hurting performance and user experience.</span></span>

<span data-ttu-id="cc2b3-311">In un interessante documento di Unity viene illustrato in dettaglio il funzionamento del Garbage Collector e vengono forniti suggerimenti per scrivere codice più efficiente dal punto di vista della gestione della memoria.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-311">Unity has provided an excellent page that explains in detail how the garbage collector works and tips to write more efficient code in regards to memory management.</span></span>
- <span data-ttu-id="cc2b3-312">[Optimizing garbage collection in Unity games](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069) (Ottimizzazione della Garbage Collection nei giochi Unity)</span><span class="sxs-lookup"><span data-stu-id="cc2b3-312">[Optimizing garbage collection in Unity games](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)</span></span>

<span data-ttu-id="cc2b3-313">Una delle procedure più comuni che porta a un numero eccessivo di Garbage Collection è la pratica di non memorizzare nella cache i riferimenti a componenti e classi nello sviluppo Unity.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-313">One of the most common practices that leads to excessive garbage collection is not caching references to components and classes in Unity development.</span></span> <span data-ttu-id="cc2b3-314">Tutti i riferimenti devono essere acquisiti durante Start() o Awake() e riutilizzati in funzioni successive come Update() o LateUpdate().</span><span class="sxs-lookup"><span data-stu-id="cc2b3-314">Any references should be captured during Start() or Awake() and re-used in later functions such as Update() or LateUpdate().</span></span>

<span data-ttu-id="cc2b3-315">Altri suggerimenti rapidi:</span><span class="sxs-lookup"><span data-stu-id="cc2b3-315">Other quick tips:</span></span>
- <span data-ttu-id="cc2b3-316">Usa la classe [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) di C# per compilare dinamicamente stringhe complesse in fase di runtime</span><span class="sxs-lookup"><span data-stu-id="cc2b3-316">Use the [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) C# class to dynamically build complex strings at runtime</span></span>
- <span data-ttu-id="cc2b3-317">Rimuovi le chiamate a Debug.Log() quando non sono più necessarie, in quanto vengono comunque eseguite in tutte le versioni delle build di un'app</span><span class="sxs-lookup"><span data-stu-id="cc2b3-317">Remove calls to Debug.Log() when no longer needed, as they still execute in all build versions of an app</span></span>
- <span data-ttu-id="cc2b3-318">Se la tua app olografica di solito richiede molta memoria, considera la possibilità di chiamare [ _**System.GC.Collect()**_ ](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) durante le fasi di caricamento, ad esempio durante la presentazione di una schermata di caricamento o di transizione</span><span class="sxs-lookup"><span data-stu-id="cc2b3-318">If your holographic app generally requires lots of memory, consider calling  [_**System.GC.Collect()**_](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) during loading phases such as when presenting a loading or transition screen</span></span>

#### <a name="object-pooling"></a><span data-ttu-id="cc2b3-319">Pooling di oggetti</span><span class="sxs-lookup"><span data-stu-id="cc2b3-319">Object pooling</span></span>

<span data-ttu-id="cc2b3-320">Il pooling di oggetti è una tecnica molto usata per ridurre i costi delle continue allocazioni e deallocazioni di oggetti.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-320">Object pooling is a popular technique to reduce the cost of continuous allocations & deallocations of objects.</span></span> <span data-ttu-id="cc2b3-321">Viene eseguito allocando un pool di grandi dimensioni di oggetti identici e riutilizzando le istanze disponibili inattive di questo pool invece di generare ed eliminare costantemente gli oggetti nel tempo.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-321">This is done by allocating a large pool of identical objects and re-using inactive, available instances from this pool instead of constantly spawning and destroying objects over time.</span></span> <span data-ttu-id="cc2b3-322">I pool di oggetti sono la soluzione ideale per i componenti riutilizzabili con durata variabile durante un'app.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-322">Object pools are great for re-useable components that have variable lifetime during an app.</span></span>

- [<span data-ttu-id="cc2b3-323">Esercitazione sul pooling di oggetti in Unity</span><span class="sxs-lookup"><span data-stu-id="cc2b3-323">Object Pooling Tutorial in Unity</span></span>](https://unity3d.com/learn/tutorials/topics/scripting/object-pooling) 

## <a name="startup-performance"></a><span data-ttu-id="cc2b3-324">Prestazioni in fase di avvio</span><span class="sxs-lookup"><span data-stu-id="cc2b3-324">Startup performance</span></span>

<span data-ttu-id="cc2b3-325">Considera la possibilità di avviare la tua app con una scena più piccola e quindi di usare *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* per caricare il resto della scena.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-325">You should consider starting your app with a smaller scene, then using *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* to load the rest of the scene.</span></span> <span data-ttu-id="cc2b3-326">Ciò consente all'app di giungere a uno stato interattivo il più velocemente possibile.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-326">This allows your app to get to an interactive state as fast as possible.</span></span> <span data-ttu-id="cc2b3-327">Tieni presente che si potrebbe registrare un considerevole picco nella CPU mentre è in corso l'attivazione della nuova scena e che per qualsiasi contenuto sottoposto a rendering potrebbero verificarsi problemi di stuttering o di blocco.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-327">Be aware that there may be a large CPU spike while the new scene is being activated and that any rendered content might stutter or hitch.</span></span> <span data-ttu-id="cc2b3-328">Un modo per ovviare a questo problema consiste nell'impostare la proprietà AsyncOperation.allowSceneActivation su "false" per la scena che viene caricata, attendere il caricamento della scena, far diventare nera la schermata e quindi reimpostare la proprietà su "true" per completare l'attivazione della scena.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-328">One way to work around this is to set the AsyncOperation.allowSceneActivation property to "false" on the scene being loaded, wait for the scene to load, clear the screen to black, and then set it back to "true" to complete the scene activation.</span></span>

<span data-ttu-id="cc2b3-329">Ricorda che, durante il caricamento della scena di avvio, all'utente verrà visualizzata la schermata iniziale olografica.</span><span class="sxs-lookup"><span data-stu-id="cc2b3-329">Remember that while the startup scene is loading, the holographic splash screen will be displayed to the user.</span></span>

## <a name="see-also"></a><span data-ttu-id="cc2b3-330">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="cc2b3-330">See also</span></span>
- <span data-ttu-id="cc2b3-331">[Optimizing graphics rendering in Unity games](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games?playlist=44069) (Ottimizzazione del rendering della grafica nei giochi Unity)</span><span class="sxs-lookup"><span data-stu-id="cc2b3-331">[Optimizing graphics rendering in Unity games](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games?playlist=44069)</span></span>
- <span data-ttu-id="cc2b3-332">[Optimizing garbage collection in Unity games](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069) (Ottimizzazione della Garbage Collection nei giochi Unity)</span><span class="sxs-lookup"><span data-stu-id="cc2b3-332">[Optimizing garbage collection in Unity games](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)</span></span>
- <span data-ttu-id="cc2b3-333">[Physics Best Practices [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) (Procedure consigliate per la fisica [Unity])</span><span class="sxs-lookup"><span data-stu-id="cc2b3-333">[Physics Best Practices [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span></span>
- <span data-ttu-id="cc2b3-334">[Optimizing Scripts [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html) (Ottimizzazione degli script [Unity])</span><span class="sxs-lookup"><span data-stu-id="cc2b3-334">[Optimizing Scripts [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span></span>
