---
title: Ottenere informazioni sulle prestazioni per realtà mista
description: Gli argomenti e informazioni dettagliate avanzate sull'ottimizzazione delle prestazioni per le App per realtà mista Windows
author: Troy-Ferrell
ms.author: trferrel
ms.date: 3/26/2019
ms.topic: article
keywords: Windows misti realtà, realtà mista, realtà virtuale, VR, MR, prestazioni, ottimizzazione, CPU, GPU
ms.openlocfilehash: ce59f9023c21dc7c981a2bb97d9fbd0c57622dbf
ms.sourcegitcommit: 384b0087899cd835a3a965f75c6f6c607c9edd1b
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/12/2019
ms.locfileid: "59603291"
---
# <a name="understanding-performance-for-mixed-reality"></a><span data-ttu-id="6ae1d-104">Ottenere informazioni sulle prestazioni per realtà mista</span><span class="sxs-lookup"><span data-stu-id="6ae1d-104">Understanding performance for mixed reality</span></span>

<span data-ttu-id="6ae1d-105">Questo articolo costituisce un'introduzione al razionalizzazione l'importanza delle prestazioni per l'app di realtà mista.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-105">This article is an introduction into rationalizing the significance of performance for your Mixed Reality app.</span></span>  <span data-ttu-id="6ae1d-106">Esperienza dell'utente può peggiorare notevolmente se l'applicazione non viene eseguito con frequenza fotogrammi ottimale.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-106">User experience can be greatly degraded if your application does not run at optimal frame rate.</span></span> <span data-ttu-id="6ae1d-107">Ologrammi apparirà instabile e head rilevamento dell'ambiente non saranno accurato comporta un'esperienza insufficiente per l'utente.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-107">Holograms will appear unstable and head tracking of the environment will be inaccurate leading to an poor experience for the user.</span></span> <span data-ttu-id="6ae1d-108">In effetti, le prestazioni devono essere considerata come una funzionalità di prima classe per lo sviluppo della realtà mista e non un stabilizzazione, la fine del ciclo di attività.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-108">Indeed, performance must be considered as a first class feature for Mixed Reality development and not a stabilization, end of cycle task.</span></span>

<span data-ttu-id="6ae1d-109">Per la revisione, i valori di frequenza dei fotogrammi ad alte prestazioni per ogni piattaforma di destinazione sono elencati di seguito.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-109">For review, the performant framerate values for each target platform are listed below.</span></span>

| <span data-ttu-id="6ae1d-110">Piattaforma</span><span class="sxs-lookup"><span data-stu-id="6ae1d-110">Platform</span></span> | <span data-ttu-id="6ae1d-111">Frequenza dei fotogrammi destinazione</span><span class="sxs-lookup"><span data-stu-id="6ae1d-111">Target Frame Rate</span></span> |
|----------|-------------------|
| [<span data-ttu-id="6ae1d-112">HoloLens</span><span class="sxs-lookup"><span data-stu-id="6ae1d-112">HoloLens</span></span>](hololens-hardware-details.md) | <span data-ttu-id="6ae1d-113">60 FPS</span><span class="sxs-lookup"><span data-stu-id="6ae1d-113">60 FPS</span></span> |
| [<span data-ttu-id="6ae1d-114">I PC Windows Mixed Reality Ultra</span><span class="sxs-lookup"><span data-stu-id="6ae1d-114">Windows Mixed Reality Ultra PCs</span></span>](immersive-headset-hardware-details.md) | <span data-ttu-id="6ae1d-115">90 FPS</span><span class="sxs-lookup"><span data-stu-id="6ae1d-115">90 FPS</span></span> |
| [<span data-ttu-id="6ae1d-116">Windows PCs realtà mista</span><span class="sxs-lookup"><span data-stu-id="6ae1d-116">Windows Mixed Reality PCs</span></span>](immersive-headset-hardware-details.md) | <span data-ttu-id="6ae1d-117">60 FPS</span><span class="sxs-lookup"><span data-stu-id="6ae1d-117">60 FPS</span></span> |

<span data-ttu-id="6ae1d-118">Il framework seguente fornisce un quadro generale per le procedure consigliate e la visione verso raggiungendo frequenze dei fotogrammi di destinazione.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-118">The framework below gives a general outline for best practices and understandings towards hitting target frame rates.</span></span> <span data-ttu-id="6ae1d-119">Per analizzare ulteriormente i dettagli, è consigliabile leggere il [raccomandazioni sulle prestazioni per l'articolo di Unity](performance-recommendations-for-unity.md).</span><span class="sxs-lookup"><span data-stu-id="6ae1d-119">To dive further into details, consider reading the [performance recommendations for Unity article](performance-recommendations-for-unity.md).</span></span> <span data-ttu-id="6ae1d-120">In particolare, questo articolo correlato illustra come misurare la frequenza dei fotogrammi le app per realtà mista di Windows di Unity, nonché passaggi da eseguire nell'ambiente di Unity per migliorare le prestazioni.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-120">In particular, this related article will discuss how to measure framerate in your Unity Windows Mixed Reality app as well as steps to take in the Unity environment to improve performance.</span></span>

## <a name="understanding-performance-bottlenecks"></a><span data-ttu-id="6ae1d-121">La comprensione dei colli di bottiglia delle prestazioni</span><span class="sxs-lookup"><span data-stu-id="6ae1d-121">Understanding performance bottlenecks</span></span>

<span data-ttu-id="6ae1d-122">Se l'app ha una frequenza dei fotogrammi con prestazioni insoddisfacenti, il primo passaggio è analizzare e comprendere l'applicazione è con calcoli complessi.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-122">If your app has an underperforming framerate, the first step is to analyze and understand where your application is computationally intensive.</span></span> <span data-ttu-id="6ae1d-123">Esistono due processori primari responsabile per il lavoro eseguire il rendering della scena: CPU e GPU.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-123">There are two primary processors responsible for the work to render your scene: the CPU and the GPU.</span></span> <span data-ttu-id="6ae1d-124">Ognuno di questi due componenti gestiscono diverse operazioni e le fasi dell'app per realtà mista.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-124">Each of these two components handle different operations and stages of your Mixed Reality app.</span></span> <span data-ttu-id="6ae1d-125">Ci sono tre posizioni principali in cui potrebbero verificarsi dei colli di bottiglia.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-125">There are three key places where bottlenecks may occur.</span></span> 

1. <span data-ttu-id="6ae1d-126">**Thread di App - CPU** -questo thread è responsabile per la logica dell'app.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-126">**App Thread - CPU** - This thread is responsible for your app logic.</span></span> <span data-ttu-id="6ae1d-127">Ciò include l'elaborazione di input, animazioni, fisica e altre app per la logica/stato</span><span class="sxs-lookup"><span data-stu-id="6ae1d-127">This includes processing input, animations, physics, and other app logic/state</span></span>
2. <span data-ttu-id="6ae1d-128">**Eseguire il rendering Thread - CPU alla GPU** -questo thread è responsabile dell'invio di chiamate di disegno nella GPU.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-128">**Render Thread - CPU to GPU** - This thread is responsible for submitting your draw calls to the GPU.</span></span> <span data-ttu-id="6ae1d-129">Quando l'app desidera eseguire il rendering di un oggetto, ad esempio un cubo o un modello, questo thread invia una richiesta per la GPU, che ha un'architettura ottimizzata per il rendering, per eseguire queste operazioni.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-129">When your app wants to render an object such as a cube or model, this thread sends a request to the GPU, which has an architecture optimized for rendering, to perform these operations.</span></span>
3. <span data-ttu-id="6ae1d-130">**GPU** - 
    questo processore gestisce in genere la pipeline di grafica dell'applicazione per trasformare i dati 3D (modelli, le trame e così via) in pixel e infine producono un'immagine 2D da inviare alla schermata del dispositivo.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-130">**GPU** - 
 This processor most commonly handles the graphics pipeline of your application to transform 3D data (models, textures, etc) into pixels and ultimately produce a 2D image to submit to your device's screen.</span></span>

![Durata di un Frame](images/lifetime-of-a-frame.png)

<span data-ttu-id="6ae1d-132">In genere, le applicazioni di HoloLens saranno GPU delimitato.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-132">Generally, HoloLens applications will be GPU bounded.</span></span> <span data-ttu-id="6ae1d-133">Tuttavia, ciò non ha valore true in ogni applicazione e pertanto è consigliabile usare gli strumenti e tecniche di seguito per ottenere verificate per l'app specifica.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-133">However, this does not hold true in every application and thus it is recommended to use the tools & techniques below to get to ground-truth for your particular app.</span></span>

## <a name="how-to-analyze-your-application"></a><span data-ttu-id="6ae1d-134">Come analizzare l'applicazione</span><span class="sxs-lookup"><span data-stu-id="6ae1d-134">How to analyze your application</span></span>

<span data-ttu-id="6ae1d-135">Sono disponibili numerosi strumenti che consentono gli sviluppatori a comprendere il profilo delle prestazioni dell'applicazione di realtà mista.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-135">There are many tools that allow you as a developer to understand the performance profile of your Mixed Reality application.</span></span> <span data-ttu-id="6ae1d-136">Questi ti permetterà di entrambi destinazione in cui si dispone di colli di bottiglia e come essi vengono manifesta autonomamente per eseguirne il debug.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-136">These will enable you to both target where you have bottlenecks and how they are manifesting themselves to debug them.</span></span>

<span data-ttu-id="6ae1d-137">Si tratta di un elenco di strumenti più diffusi e potenti per ottenere informazioni di profilatura approfondite per l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-137">This is a list of popular and powerful tools to gain deep profiling information for your application.</span></span>
- [<span data-ttu-id="6ae1d-138">Analizzatori di prestazioni della grafica di Intel</span><span class="sxs-lookup"><span data-stu-id="6ae1d-138">Intel Graphics Performance Analyzers</span></span>](https://software.intel.com/gpa)
- [<span data-ttu-id="6ae1d-139">Debugger grafica di Visual Studio</span><span class="sxs-lookup"><span data-stu-id="6ae1d-139">Visual Studio Graphics Debuggers</span></span>](https://docs.microsoft.com/visualstudio/debugger/graphics/visual-studio-graphics-diagnostics?view=vs-2017)
- [<span data-ttu-id="6ae1d-140">Unity Profiler</span><span class="sxs-lookup"><span data-stu-id="6ae1d-140">Unity Profiler</span></span>](https://docs.unity3d.com/Manual/Profiler.html)
- [<span data-ttu-id="6ae1d-141">Debugger di Unity Frame</span><span class="sxs-lookup"><span data-stu-id="6ae1d-141">Unity Frame Debugger</span></span>](https://docs.unity3d.com/Manual/FrameDebugger.html)

### <a name="how-to-profile-in-any-environment"></a><span data-ttu-id="6ae1d-142">Come eseguire la profilatura in qualsiasi ambiente</span><span class="sxs-lookup"><span data-stu-id="6ae1d-142">How to profile in any environment</span></span>

<span data-ttu-id="6ae1d-143">Si verifica un semplice test per determinare rapidamente che se è probabile che con GPU o CPU delimitato nell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-143">There is a simple test to quickly determine if you are likely GPU bounded or CPU bounded in your application.</span></span> <span data-ttu-id="6ae1d-144">Se si diminuisce la risoluzione dell'output della destinazione di rendering, sono presenti meno pixel per calcolare e di conseguenza, minore di lavoro GPU deve eseguire per il rendering di un'immagine.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-144">If you decrease the resolution of the render target output, there are less pixels to calculate and thus, less work the GPU needs to perform to render an image.</span></span> <span data-ttu-id="6ae1d-145">Viewport ridimensionamento (ridimensionamento di risoluzione dinamica) è la pratica per il rendering di immagini al valore più piccolo della destinazione di rendering quindi possibile visualizzare il dispositivo di output.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-145">Viewport scaling (dynamic resolution scaling) is the practice of rendering your image to a smaller render target then your output device can display.</span></span> <span data-ttu-id="6ae1d-146">Il dispositivo verrà up-sample dal più piccolo set di pixel per visualizzare l'immagine finale.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-146">The device will up-sample from the smaller set of pixels to display your final image.</span></span>

<span data-ttu-id="6ae1d-147">Dopo aver diminuendo la risoluzione per il rendering, se:</span><span class="sxs-lookup"><span data-stu-id="6ae1d-147">After decreasing rendering resolution, if:</span></span>
1) <span data-ttu-id="6ae1d-148">Frequenza dei fotogrammi dell'applicazione **aumenta**, quindi è probabile che **delimitato GPU**</span><span class="sxs-lookup"><span data-stu-id="6ae1d-148">Application framerate **increases**, then you are likely **GPU Bounded**</span></span>
1) <span data-ttu-id="6ae1d-149">Frequenza dei fotogrammi dell'applicazione **invariato**, quindi è probabile che **della CPU limitato**</span><span class="sxs-lookup"><span data-stu-id="6ae1d-149">Application framerate **unchanged**, then you are likely **CPU Bounded**</span></span>

>[!NOTE]
><span data-ttu-id="6ae1d-150">Unity offre la possibilità di modificare facilmente la risoluzione di destinazione di rendering dell'applicazione in fase di esecuzione tramite il *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* proprietà.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-150">Unity provides the ability to easily modify the render target resolution of your application at runtime through the *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* property.</span></span> <span data-ttu-id="6ae1d-151">L'immagine finale visualizzata sul dispositivo ha una risoluzione fissa.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-151">The final image presented on device has a fixed resolution.</span></span> <span data-ttu-id="6ae1d-152">La piattaforma campionerà le risoluzione più bassa per compilare un'immagine con risoluzione superiore per il rendering a su schermi di output.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-152">The platform will sample the lower resolution output to build a higher resolution image for rendering on displays.</span></span> 
>
>```CS
>UnityEngine.XR.XRSettings.renderScale = 0.7f;
>```

## <a name="how-to-improve-your-application"></a><span data-ttu-id="6ae1d-153">Come migliorare l'applicazione</span><span class="sxs-lookup"><span data-stu-id="6ae1d-153">How to improve your application</span></span>

### <a name="cpu-performance-recommendations"></a><span data-ttu-id="6ae1d-154">Raccomandazioni per le prestazioni della CPU</span><span class="sxs-lookup"><span data-stu-id="6ae1d-154">CPU performance recommendations</span></span>

<span data-ttu-id="6ae1d-155">In generale, la maggior parte delle operazioni in un'applicazione di realtà mista sulla CPU comporta eseguendo "simulazione" della scena e l'elaborazione della logica di approfonditi delle applicazioni univoco.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-155">Generally, most work in a mixed reality application on the CPU involves performing the "simulation" of the scene and processing extensive unique application logic.</span></span> <span data-ttu-id="6ae1d-156">Di conseguenza, le aree seguenti sono generalmente destinate per l'ottimizzazione.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-156">Thus, the following areas are usually targeted for optimization.</span></span>

- <span data-ttu-id="6ae1d-157">Animazioni</span><span class="sxs-lookup"><span data-stu-id="6ae1d-157">Animations</span></span>
- <span data-ttu-id="6ae1d-158">Semplificare la fisica</span><span class="sxs-lookup"><span data-stu-id="6ae1d-158">Simplify Physics</span></span>
- <span data-ttu-id="6ae1d-159">Allocazioni di memoria</span><span class="sxs-lookup"><span data-stu-id="6ae1d-159">Memory allocations</span></span>
- <span data-ttu-id="6ae1d-160">Algoritmi complessi (ad es.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-160">Complex algorithms (i.e</span></span> <span data-ttu-id="6ae1d-161">cinematica inversa, percorso di ricerca)</span><span class="sxs-lookup"><span data-stu-id="6ae1d-161">inverse kinematics, path-finding)</span></span>

### <a name="gpu-performance-recommendations"></a><span data-ttu-id="6ae1d-162">Raccomandazioni sulle prestazioni di GPU</span><span class="sxs-lookup"><span data-stu-id="6ae1d-162">GPU performance recommendations</span></span>

#### <a name="understanding-bandwidth-vs-fill-rate"></a><span data-ttu-id="6ae1d-163">Velocità di riempimento di comprensione della larghezza di banda Visual Studio</span><span class="sxs-lookup"><span data-stu-id="6ae1d-163">Understanding bandwidth vs fill rate</span></span>
<span data-ttu-id="6ae1d-164">Durante il rendering di un frame nella GPU, un'applicazione è in genere vincolata dalla velocità di riempimento o la larghezza di banda di memoria.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-164">When rendering a frame on the GPU, an application is generally either bounded by memory bandwidth or fill rate.</span></span>

- <span data-ttu-id="6ae1d-165">**Larghezza di banda di memoria** indica la frequenza delle letture e scritture GPU è possibile eseguire dalla memoria</span><span class="sxs-lookup"><span data-stu-id="6ae1d-165">**Memory bandwidth** is the rate of reads and writes the GPU can perform from memory</span></span>
    - <span data-ttu-id="6ae1d-166">Per identificare le limitazioni della larghezza di banda, ridurre la qualità della trama e controllare se la frequenza dei fotogrammi migliorate.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-166">To identify bandwidth limitations, reduce texture quality and check if framerate improved.</span></span>
    - <span data-ttu-id="6ae1d-167">In Unity, questa operazione può essere eseguita modificando **trama qualità** nelle **modificare** > **impostazioni progetto**  >   **[ Impostazioni relative alla qualità](https://docs.unity3d.com/Manual/class-QualitySettings.html)**.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-167">In Unity, this can be done by changing **Texture Quality** in **Edit** > **Project Settings** > **[Quality Settings](https://docs.unity3d.com/Manual/class-QualitySettings.html)**.</span></span>
- <span data-ttu-id="6ae1d-168">**Velocità di riempimento** fa riferimento alla velocità effettiva di pixel viene eseguito il rendering che possono essere disegnate al secondo dalla GPU.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-168">**Fill rate** refers to the throughput of rendered pixels that can be drawn per second by the GPU.</span></span>
    - <span data-ttu-id="6ae1d-169">Per identificare le limitazioni di velocità di riempimento, ridurre la risoluzione dello schermo e controllare se la frequenza dei fotogrammi migliorate.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-169">To identify fill rate limitations, decrease the display resolution and check if framerate improved.</span></span> 
    - <span data-ttu-id="6ae1d-170">In Unity, questa operazione può essere eseguita tramite il *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* proprietà</span><span class="sxs-lookup"><span data-stu-id="6ae1d-170">In Unity, this can be done via the  *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* property</span></span>

<span data-ttu-id="6ae1d-171">Larghezza di banda di memoria implica in genere le ottimizzazioni a uno</span><span class="sxs-lookup"><span data-stu-id="6ae1d-171">Memory bandwidth generally involves optimizations to either</span></span>
1) <span data-ttu-id="6ae1d-172">ridurre le risoluzioni di trama</span><span class="sxs-lookup"><span data-stu-id="6ae1d-172">decrease texture resolutions</span></span>
2) <span data-ttu-id="6ae1d-173">usare meno trame (ad es.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-173">utilize less textures (i.e</span></span> <span data-ttu-id="6ae1d-174">e così via con riflessione speculare, Normals)</span><span class="sxs-lookup"><span data-stu-id="6ae1d-174">normals, specular, etc)</span></span>

<span data-ttu-id="6ae1d-175">Velocità di riempimento è mirata principalmente alla riduzione del numero di operazioni che devono essere calcolati per un pixel sottoposto a rendering finale.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-175">Fill rate is primarily focused on reducing the number of operations that need to be computed for a final rendered pixel.</span></span> <span data-ttu-id="6ae1d-176">Esempi di questo genere rientrano in riduzione</span><span class="sxs-lookup"><span data-stu-id="6ae1d-176">Examples of this commonly fall into reducing</span></span>
1) <span data-ttu-id="6ae1d-177">numero di oggetti di rendering/processo</span><span class="sxs-lookup"><span data-stu-id="6ae1d-177">number of objects to render/process</span></span>
2) <span data-ttu-id="6ae1d-178">numero di operazioni per shader</span><span class="sxs-lookup"><span data-stu-id="6ae1d-178">number of operations per shader</span></span>
3) <span data-ttu-id="6ae1d-179">numero di fasi GPU al risultato finale (geometry shader, post-elaborazione effetti e così via)</span><span class="sxs-lookup"><span data-stu-id="6ae1d-179">number of GPU stages to final result (geometry shaders, post-processing effects, etc)</span></span>
4) <span data-ttu-id="6ae1d-180">numero di pixel per il rendering (ad es.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-180">number of pixels to render (i.e</span></span> <span data-ttu-id="6ae1d-181">risoluzione dello schermo)</span><span class="sxs-lookup"><span data-stu-id="6ae1d-181">display resolution)</span></span>

#### <a name="reduce-poly-count"></a><span data-ttu-id="6ae1d-182">Ridurre il numero di poligono</span><span class="sxs-lookup"><span data-stu-id="6ae1d-182">Reduce poly count</span></span>
<span data-ttu-id="6ae1d-183">Poligono superiore Conta risultati di ulteriori operazioni per la GPU e riducendo il numero di poligoni in scena ridurrà la quantità di tempo per eseguire il rendering che la geometria.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-183">Higher polygon counts result in more operations for the GPU and reducing the number of polygons in your scene will reduce the amount of time to render that geometry.</span></span> <span data-ttu-id="6ae1d-184">Esistono altri fattori interessati anche ombreggiatura la geometria che può ancora essere costosa, ma count poligono è la metrica di base per determinare il costo una scena sarà per il rendering.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-184">There are other factors involved as well in shading the geometry that can still be expensive but polygon count is the base metric to determine how expensive a scene will be to render.</span></span>

#### <a name="limit-overdraw"></a><span data-ttu-id="6ae1d-185">Limite di caricamento</span><span class="sxs-lookup"><span data-stu-id="6ae1d-185">Limit overdraw</span></span>

<span data-ttu-id="6ae1d-186">Alto estenda si verifica quando più oggetti sono sottoposto a rendering ma non restituiti alla schermata di come sono nascosti da un altro, in genere più da vicino, occluding oggetto.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-186">High overdraw occurs when multiple objects are rendered but not outputted to the screen as they are hidden by another, generally closer, occluding object.</span></span> <span data-ttu-id="6ae1d-187">Si supponga esaminando una parete che aveva più le chat e geometry dietro di essa.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-187">Imagine looking at a wall that had multiple rooms and geometry behind it.</span></span> <span data-ttu-id="6ae1d-188">Sarebbe elaborati tutti la geometria per il rendering, ma solo la parete opaca informazione che invece deve essere sottoposto a rendering come lo occludes la visualizzazione di tutti gli altri contenuti.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-188">All of the geometry would be processed for rendering but only the opaque wall really needs to be rendered as it occludes the view of all other content.</span></span> <span data-ttu-id="6ae1d-189">Ciò comporta operazioni inutili che non sono necessari per la visualizzazione corrente.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-189">This results in wasteful operations that are not needed for the current view.</span></span>

#### <a name="shaders"></a><span data-ttu-id="6ae1d-190">Shader</span><span class="sxs-lookup"><span data-stu-id="6ae1d-190">Shaders</span></span>

<span data-ttu-id="6ae1d-191">Gli shader sono piccoli programmi eseguiti sulla GPU e determinano in genere due operazioni importanti per il rendering:</span><span class="sxs-lookup"><span data-stu-id="6ae1d-191">Shaders are small programs that run on the GPU and generally determine two important steps in rendering:</span></span>
1) <span data-ttu-id="6ae1d-192">vertici dell'oggetto che devono essere disegnati sullo schermo e si trovino nello spazio dello schermo (ad es.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-192">which object's vertices should be drawn on the screen and where they are in screen space (i.e</span></span> <span data-ttu-id="6ae1d-193">Vertex shader)</span><span class="sxs-lookup"><span data-stu-id="6ae1d-193">the Vertex shader)</span></span>
    - <span data-ttu-id="6ae1d-194">Vertex shader viene in genere eseguito per ogni vertice per ogni GameObject</span><span class="sxs-lookup"><span data-stu-id="6ae1d-194">The Vertex shader is generally executed per vertex for every GameObject</span></span>
2) <span data-ttu-id="6ae1d-195">che cosa colorare i pixel (ad es.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-195">what to color those pixels (i.e</span></span> <span data-ttu-id="6ae1d-196">il Pixel shader)</span><span class="sxs-lookup"><span data-stu-id="6ae1d-196">the Pixel shader)</span></span>
    - <span data-ttu-id="6ae1d-197">Il Pixel shader viene eseguito per ogni pixel per la trama viene eseguito il rendering per il dispositivo presenta</span><span class="sxs-lookup"><span data-stu-id="6ae1d-197">The Pixel shader is executed per pixel for the texture being rendered for device present</span></span>

<span data-ttu-id="6ae1d-198">In genere gli shader eseguono numerose trasformazioni e calcoli di illuminazione.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-198">Typically shaders perform many transformations and lighting calculations.</span></span> <span data-ttu-id="6ae1d-199">Anche se i modelli di illuminazione complesse, ombreggiature e altre operazioni possono generare risultati fantastici, sono inoltre dotati di un prezzo.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-199">Although complex lighting models, shadows, and other operations can generate fantastic results, they also come with a price.</span></span> <span data-ttu-id="6ae1d-200">Riduzione del numero di operazioni calcolate di shader possono ridurre notevolmente il lavoro complessivo necessario per essere eseguita da una GPU per ogni fotogramma.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-200">Reducing the number of operations computed in shaders can greatly reduce the overall work needed to be done by a GPU per frame.</span></span>

##### <a name="shader-coding-recommendations"></a><span data-ttu-id="6ae1d-201">Shader suggerimenti di codifica</span><span class="sxs-lookup"><span data-stu-id="6ae1d-201">Shader coding recommendations</span></span>

- <span data-ttu-id="6ae1d-202">Usare il filtraggio bilineare quando possibile</span><span class="sxs-lookup"><span data-stu-id="6ae1d-202">Use bilinear filtering whenever possible</span></span>
- <span data-ttu-id="6ae1d-203">Ridisporre le espressioni per l'uso di funzioni intrinseche MAD scopo un multiply e un'operazione di aggiunta allo stesso tempo</span><span class="sxs-lookup"><span data-stu-id="6ae1d-203">Rearrange expressions to use MAD intrinsics in order to do a multiply and an add at the same time</span></span>
- <span data-ttu-id="6ae1d-204">Precalcolare quanto più possibile sulla CPU e passare come costanti per il materiale</span><span class="sxs-lookup"><span data-stu-id="6ae1d-204">Precalculate as much as possible on the CPU and pass as constants to the material</span></span>
- <span data-ttu-id="6ae1d-205">**Ottimizza per lo spostamento delle operazioni dal pixel shader al vertex shader**</span><span class="sxs-lookup"><span data-stu-id="6ae1d-205">**Favor moving operations from the pixel shader to the vertex shader**</span></span>
    - <span data-ttu-id="6ae1d-206">In genere il numero di vertici << & di pixel (ad es.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-206">Generally the # of vertices << # of pixels (i.e</span></span> <span data-ttu-id="6ae1d-207">720p = = 921.600 pixel, con risoluzione 1080p e = = 2.073.600 pixel e così via)</span><span class="sxs-lookup"><span data-stu-id="6ae1d-207">720p == 921,600 pixels, 1080p == 2,073,600 pixels, etc)</span></span>

#### <a name="remove-gpu-stages"></a><span data-ttu-id="6ae1d-208">Rimuovere fasi GPU</span><span class="sxs-lookup"><span data-stu-id="6ae1d-208">Remove GPU stages</span></span>
<span data-ttu-id="6ae1d-209">Gli effetti di post-elaborazione possono essere molto costosa e inibire in genere la velocità di riempimento dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-209">Post-processing effects can be very expensive and generally inhibit the fill rate of your application.</span></span> <span data-ttu-id="6ae1d-210">Ciò include anche le tecniche di anti-aliasing, ad esempio MSAA.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-210">This also includes anti-aliasing techniques such as MSAA.</span></span> <span data-ttu-id="6ae1d-211">Su HoloLens, è consigliabile evitare interamente queste tecniche.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-211">On HoloLens, it is recommended to avoid these techniques entirely.</span></span> <span data-ttu-id="6ae1d-212">Inoltre, è consigliabile evitare fasi dello shader aggiuntive, ad esempio compute shader, hull e geometry quando possibile.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-212">Furthermore, additional shader stages such as geometry, hull, and compute shaders should be avoided when possible.</span></span>

## <a name="memory-recommendations"></a><span data-ttu-id="6ae1d-213">Consigli sulla memoria</span><span class="sxs-lookup"><span data-stu-id="6ae1d-213">Memory recommendations</span></span>
<span data-ttu-id="6ae1d-214">Operazioni di allocazione e deallocazione di memoria eccessiva possono avere effetti negativi sull'applicazione holographic causando prestazioni incoerenti, frame bloccati e altri comportamenti dannosi.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-214">Excessive memory allocation & deallocation operations can have adverse effects on your holographic application resulting in inconsistent performance, frozen frames, and other detrimental behavior.</span></span> <span data-ttu-id="6ae1d-215">È particolarmente importante comprendere considerazioni sulla memoria quando si sviluppa in Unity, poiché la gestione della memoria è controllata dal garbage collector.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-215">It is especially important to understand memory considerations when developing in Unity since memory management is controlled by the garbage collector.</span></span>

#### <a name="object-pooling"></a><span data-ttu-id="6ae1d-216">Pool di oggetti</span><span class="sxs-lookup"><span data-stu-id="6ae1d-216">Object pooling</span></span>

<span data-ttu-id="6ae1d-217">Il pool degli oggetti è una tecnica comune per ridurre il costo delle allocazioni di continuo e le deallocazioni di oggetti.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-217">Object pooling is a popular technique to reduce the cost of continuous allocations & deallocations of objects.</span></span> <span data-ttu-id="6ae1d-218">Questa operazione viene eseguita, allocando un ampio pool di oggetti identici e riutilizzo di istanze inattive, disponibile da questo pool anziché continuamente durante la generazione e l'eliminazione definitiva di oggetti nel corso del tempo.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-218">This is done by allocating a large pool of identical objects and re-using inactive, available instances from this pool instead of constantly spawning and destroying objects over time.</span></span> <span data-ttu-id="6ae1d-219">Pool di oggetti sono ideali per i componenti riutilizzabili che includono la durata delle variabili durante un'app.</span><span class="sxs-lookup"><span data-stu-id="6ae1d-219">Object pools are great for re-useable components that have variable lifetime during an app.</span></span>

## <a name="see-also"></a><span data-ttu-id="6ae1d-220">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="6ae1d-220">See also</span></span>
- [<span data-ttu-id="6ae1d-221">Raccomandazioni sulle prestazioni per Unity</span><span class="sxs-lookup"><span data-stu-id="6ae1d-221">Performance recommendations for Unity</span></span>](performance-recommendations-for-unity.md)
- [<span data-ttu-id="6ae1d-222">Impostazioni consigliate per Unity</span><span class="sxs-lookup"><span data-stu-id="6ae1d-222">Recommended settings for Unity</span></span>](recommended-settings-for-unity.md)
