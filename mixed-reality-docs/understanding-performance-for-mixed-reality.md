---
title: Informazioni sulle prestazioni per la realtà mista
description: Argomenti avanzati e dettagli sull'ottimizzazione delle prestazioni per le app di realtà mista di Windows
author: Troy-Ferrell
ms.author: trferrel
ms.date: 3/26/2019
ms.topic: article
keywords: Realtà mista di Windows, realtà mista, realtà virtuale, VR, MR, prestazioni, ottimizzazione, CPU, GPU
ms.openlocfilehash: ce59f9023c21dc7c981a2bb97d9fbd0c57622dbf
ms.sourcegitcommit: 915d3cc63a5571ba22ac4608589f3eca8da1bc81
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/24/2019
ms.locfileid: "63548832"
---
# <a name="understanding-performance-for-mixed-reality"></a><span data-ttu-id="2f883-104">Informazioni sulle prestazioni per la realtà mista</span><span class="sxs-lookup"><span data-stu-id="2f883-104">Understanding performance for mixed reality</span></span>

<span data-ttu-id="2f883-105">Questo articolo è un'introduzione alla razionalizzazione dell'importanza delle prestazioni per l'app per realtà mista.</span><span class="sxs-lookup"><span data-stu-id="2f883-105">This article is an introduction into rationalizing the significance of performance for your Mixed Reality app.</span></span>  <span data-ttu-id="2f883-106">L'esperienza utente può essere notevolmente degradata se l'applicazione non viene eseguita con una frequenza di fotogrammi ottimale.</span><span class="sxs-lookup"><span data-stu-id="2f883-106">User experience can be greatly degraded if your application does not run at optimal frame rate.</span></span> <span data-ttu-id="2f883-107">Gli ologrammi appariranno instabile e il rilevamento delle intestazioni dell'ambiente non sarà accurato, causando una scarsa esperienza per l'utente.</span><span class="sxs-lookup"><span data-stu-id="2f883-107">Holograms will appear unstable and head tracking of the environment will be inaccurate leading to an poor experience for the user.</span></span> <span data-ttu-id="2f883-108">Infatti, le prestazioni devono essere considerate come una funzionalità di prima classe per lo sviluppo di realtà mista e non una stabilizzazione, fine dell'attività del ciclo.</span><span class="sxs-lookup"><span data-stu-id="2f883-108">Indeed, performance must be considered as a first class feature for Mixed Reality development and not a stabilization, end of cycle task.</span></span>

<span data-ttu-id="2f883-109">Per la revisione, i valori di framerate per ogni piattaforma di destinazione sono elencati di seguito.</span><span class="sxs-lookup"><span data-stu-id="2f883-109">For review, the performant framerate values for each target platform are listed below.</span></span>

| <span data-ttu-id="2f883-110">Piattaforma</span><span class="sxs-lookup"><span data-stu-id="2f883-110">Platform</span></span> | <span data-ttu-id="2f883-111">Frequenza fotogrammi di destinazione</span><span class="sxs-lookup"><span data-stu-id="2f883-111">Target Frame Rate</span></span> |
|----------|-------------------|
| [<span data-ttu-id="2f883-112">HoloLens</span><span class="sxs-lookup"><span data-stu-id="2f883-112">HoloLens</span></span>](hololens-hardware-details.md) | <span data-ttu-id="2f883-113">60 FPS</span><span class="sxs-lookup"><span data-stu-id="2f883-113">60 FPS</span></span> |
| [<span data-ttu-id="2f883-114">Windows reality Ultra PC</span><span class="sxs-lookup"><span data-stu-id="2f883-114">Windows Mixed Reality Ultra PCs</span></span>](immersive-headset-hardware-details.md) | <span data-ttu-id="2f883-115">90 FPS</span><span class="sxs-lookup"><span data-stu-id="2f883-115">90 FPS</span></span> |
| [<span data-ttu-id="2f883-116">PC con realtà mista di Windows</span><span class="sxs-lookup"><span data-stu-id="2f883-116">Windows Mixed Reality PCs</span></span>](immersive-headset-hardware-details.md) | <span data-ttu-id="2f883-117">60 FPS</span><span class="sxs-lookup"><span data-stu-id="2f883-117">60 FPS</span></span> |

<span data-ttu-id="2f883-118">Il Framework seguente fornisce un contorno generale per le procedure consigliate e le comprensioni per raggiungere le frequenze dei fotogrammi di destinazione.</span><span class="sxs-lookup"><span data-stu-id="2f883-118">The framework below gives a general outline for best practices and understandings towards hitting target frame rates.</span></span> <span data-ttu-id="2f883-119">Per approfondire i dettagli, provare a leggere l' [articolo raccomandazioni sulle prestazioni per Unity](performance-recommendations-for-unity.md).</span><span class="sxs-lookup"><span data-stu-id="2f883-119">To dive further into details, consider reading the [performance recommendations for Unity article](performance-recommendations-for-unity.md).</span></span> <span data-ttu-id="2f883-120">In particolare, questo articolo correlato descrive come misurare il framerate nell'app per la realtà mista di Windows Unity e i passaggi da eseguire nell'ambiente Unity per migliorare le prestazioni.</span><span class="sxs-lookup"><span data-stu-id="2f883-120">In particular, this related article will discuss how to measure framerate in your Unity Windows Mixed Reality app as well as steps to take in the Unity environment to improve performance.</span></span>

## <a name="understanding-performance-bottlenecks"></a><span data-ttu-id="2f883-121">Informazioni sui colli di bottiglia delle prestazioni</span><span class="sxs-lookup"><span data-stu-id="2f883-121">Understanding performance bottlenecks</span></span>

<span data-ttu-id="2f883-122">Se l'app ha un framerate sottoposto a sottoesecuzione, il primo passaggio consiste nell'analizzare e comprendere il modo in cui l'applicazione è a elevato utilizzo di calcolo.</span><span class="sxs-lookup"><span data-stu-id="2f883-122">If your app has an underperforming framerate, the first step is to analyze and understand where your application is computationally intensive.</span></span> <span data-ttu-id="2f883-123">Ci sono due processori primari responsabili del lavoro per il rendering della scena: CPU e GPU.</span><span class="sxs-lookup"><span data-stu-id="2f883-123">There are two primary processors responsible for the work to render your scene: the CPU and the GPU.</span></span> <span data-ttu-id="2f883-124">Ognuno di questi due componenti gestisce diverse operazioni e fasi dell'app per realtà mista.</span><span class="sxs-lookup"><span data-stu-id="2f883-124">Each of these two components handle different operations and stages of your Mixed Reality app.</span></span> <span data-ttu-id="2f883-125">I colli di bottiglia possono verificarsi in tre punti chiave.</span><span class="sxs-lookup"><span data-stu-id="2f883-125">There are three key places where bottlenecks may occur.</span></span> 

1. <span data-ttu-id="2f883-126">**Thread-CPU dell'app** : questo thread è responsabile della logica dell'app.</span><span class="sxs-lookup"><span data-stu-id="2f883-126">**App Thread - CPU** - This thread is responsible for your app logic.</span></span> <span data-ttu-id="2f883-127">Sono inclusi l'elaborazione di input, animazioni, fisica e altro stato/logica dell'app</span><span class="sxs-lookup"><span data-stu-id="2f883-127">This includes processing input, animations, physics, and other app logic/state</span></span>
2. <span data-ttu-id="2f883-128">**Render thread-CPU alla GPU** : questo thread è responsabile dell'invio delle chiamate di disegnare alla GPU.</span><span class="sxs-lookup"><span data-stu-id="2f883-128">**Render Thread - CPU to GPU** - This thread is responsible for submitting your draw calls to the GPU.</span></span> <span data-ttu-id="2f883-129">Quando l'app vuole eseguire il rendering di un oggetto, ad esempio un cubo o un modello, questo thread invia una richiesta alla GPU, che ha un'architettura ottimizzata per il rendering, per eseguire queste operazioni.</span><span class="sxs-lookup"><span data-stu-id="2f883-129">When your app wants to render an object such as a cube or model, this thread sends a request to the GPU, which has an architecture optimized for rendering, to perform these operations.</span></span>
3. <span data-ttu-id="2f883-130">**GPU** - 
    Questo processore gestisce più di frequente la pipeline grafica dell'applicazione per trasformare i dati 3D (modelli, trame e così via) in pixel e infine produrre un'immagine 2D da inviare alla schermata del dispositivo.</span><span class="sxs-lookup"><span data-stu-id="2f883-130">**GPU** - 
 This processor most commonly handles the graphics pipeline of your application to transform 3D data (models, textures, etc) into pixels and ultimately produce a 2D image to submit to your device's screen.</span></span>

![Durata di un frame](images/lifetime-of-a-frame.png)

<span data-ttu-id="2f883-132">In genere, le applicazioni HoloLens saranno delimitate da GPU.</span><span class="sxs-lookup"><span data-stu-id="2f883-132">Generally, HoloLens applications will be GPU bounded.</span></span> <span data-ttu-id="2f883-133">Tuttavia, ciò non è valido in ogni applicazione ed è quindi consigliabile usare gli strumenti & tecniche seguenti per ottenere una verità per la propria app.</span><span class="sxs-lookup"><span data-stu-id="2f883-133">However, this does not hold true in every application and thus it is recommended to use the tools & techniques below to get to ground-truth for your particular app.</span></span>

## <a name="how-to-analyze-your-application"></a><span data-ttu-id="2f883-134">Come analizzare l'applicazione</span><span class="sxs-lookup"><span data-stu-id="2f883-134">How to analyze your application</span></span>

<span data-ttu-id="2f883-135">Sono disponibili molti strumenti che consentono agli sviluppatori di comprendere il profilo delle prestazioni dell'applicazione per realtà mista.</span><span class="sxs-lookup"><span data-stu-id="2f883-135">There are many tools that allow you as a developer to understand the performance profile of your Mixed Reality application.</span></span> <span data-ttu-id="2f883-136">Queste consentiranno di raggiungere entrambi i colli di bottiglia e il modo in cui si manifestano per eseguirne il debug.</span><span class="sxs-lookup"><span data-stu-id="2f883-136">These will enable you to both target where you have bottlenecks and how they are manifesting themselves to debug them.</span></span>

<span data-ttu-id="2f883-137">Questo è un elenco di strumenti diffusi e potenti per ottenere informazioni di profilatura approfondite per l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="2f883-137">This is a list of popular and powerful tools to gain deep profiling information for your application.</span></span>
- [<span data-ttu-id="2f883-138">Analizzatori prestazioni grafica Intel</span><span class="sxs-lookup"><span data-stu-id="2f883-138">Intel Graphics Performance Analyzers</span></span>](https://software.intel.com/gpa)
- [<span data-ttu-id="2f883-139">Debugger grafica di Visual Studio</span><span class="sxs-lookup"><span data-stu-id="2f883-139">Visual Studio Graphics Debuggers</span></span>](https://docs.microsoft.com/visualstudio/debugger/graphics/visual-studio-graphics-diagnostics?view=vs-2017)
- [<span data-ttu-id="2f883-140">Profiler Unity</span><span class="sxs-lookup"><span data-stu-id="2f883-140">Unity Profiler</span></span>](https://docs.unity3d.com/Manual/Profiler.html)
- [<span data-ttu-id="2f883-141">Debugger frame Unity</span><span class="sxs-lookup"><span data-stu-id="2f883-141">Unity Frame Debugger</span></span>](https://docs.unity3d.com/Manual/FrameDebugger.html)

### <a name="how-to-profile-in-any-environment"></a><span data-ttu-id="2f883-142">Come profilare in qualsiasi ambiente</span><span class="sxs-lookup"><span data-stu-id="2f883-142">How to profile in any environment</span></span>

<span data-ttu-id="2f883-143">È disponibile un semplice test per determinare rapidamente se è probabile che la GPU sia limitata o associata alla CPU nell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="2f883-143">There is a simple test to quickly determine if you are likely GPU bounded or CPU bounded in your application.</span></span> <span data-ttu-id="2f883-144">Se si riduce la risoluzione dell'output della destinazione di rendering, sono presenti meno pixel da calcolare e, di conseguenza, un numero minore di operazioni che la GPU deve eseguire per il rendering di un'immagine.</span><span class="sxs-lookup"><span data-stu-id="2f883-144">If you decrease the resolution of the render target output, there are less pixels to calculate and thus, less work the GPU needs to perform to render an image.</span></span> <span data-ttu-id="2f883-145">Il ridimensionamento del viewport (scala della risoluzione dinamica) è la procedura per eseguire il rendering dell'immagine in una destinazione di rendering più piccola, quindi è possibile visualizzare il dispositivo di output.</span><span class="sxs-lookup"><span data-stu-id="2f883-145">Viewport scaling (dynamic resolution scaling) is the practice of rendering your image to a smaller render target then your output device can display.</span></span> <span data-ttu-id="2f883-146">Il dispositivo viene sottoposto a esempio dal set di pixel più piccolo per visualizzare l'immagine finale.</span><span class="sxs-lookup"><span data-stu-id="2f883-146">The device will up-sample from the smaller set of pixels to display your final image.</span></span>

<span data-ttu-id="2f883-147">Dopo la riduzione della risoluzione del rendering, se:</span><span class="sxs-lookup"><span data-stu-id="2f883-147">After decreasing rendering resolution, if:</span></span>
1) <span data-ttu-id="2f883-148">Il framerate dell'applicazione **aumenta**, quindi è probabile che la **GPU sia limitata**</span><span class="sxs-lookup"><span data-stu-id="2f883-148">Application framerate **increases**, then you are likely **GPU Bounded**</span></span>
1) <span data-ttu-id="2f883-149">Framerate dell'applicazione senza **modifiche**, è probabile che la **CPU sia limitata**</span><span class="sxs-lookup"><span data-stu-id="2f883-149">Application framerate **unchanged**, then you are likely **CPU Bounded**</span></span>

>[!NOTE]
><span data-ttu-id="2f883-150">Unity offre la possibilità di modificare facilmente la risoluzione della destinazione di rendering dell'applicazione in fase di esecuzione tramite la proprietà *[XRSettings. renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* .</span><span class="sxs-lookup"><span data-stu-id="2f883-150">Unity provides the ability to easily modify the render target resolution of your application at runtime through the *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* property.</span></span> <span data-ttu-id="2f883-151">La risoluzione dell'immagine finale visualizzata sul dispositivo è fissa.</span><span class="sxs-lookup"><span data-stu-id="2f883-151">The final image presented on device has a fixed resolution.</span></span> <span data-ttu-id="2f883-152">La piattaforma campiona l'output di risoluzione inferiore per creare un'immagine di risoluzione superiore per il rendering delle visualizzazioni.</span><span class="sxs-lookup"><span data-stu-id="2f883-152">The platform will sample the lower resolution output to build a higher resolution image for rendering on displays.</span></span> 
>
>```CS
>UnityEngine.XR.XRSettings.renderScale = 0.7f;
>```

## <a name="how-to-improve-your-application"></a><span data-ttu-id="2f883-153">Come migliorare l'applicazione</span><span class="sxs-lookup"><span data-stu-id="2f883-153">How to improve your application</span></span>

### <a name="cpu-performance-recommendations"></a><span data-ttu-id="2f883-154">Raccomandazioni sulle prestazioni della CPU</span><span class="sxs-lookup"><span data-stu-id="2f883-154">CPU performance recommendations</span></span>

<span data-ttu-id="2f883-155">In genere, la maggior parte del lavoro in un'applicazione di realtà mista sulla CPU comporta l'esecuzione della "simulazione" della scena e l'elaborazione di una logica dell'applicazione univoca completa.</span><span class="sxs-lookup"><span data-stu-id="2f883-155">Generally, most work in a mixed reality application on the CPU involves performing the "simulation" of the scene and processing extensive unique application logic.</span></span> <span data-ttu-id="2f883-156">Pertanto, le aree seguenti sono in genere destinate all'ottimizzazione.</span><span class="sxs-lookup"><span data-stu-id="2f883-156">Thus, the following areas are usually targeted for optimization.</span></span>

- <span data-ttu-id="2f883-157">Animazioni</span><span class="sxs-lookup"><span data-stu-id="2f883-157">Animations</span></span>
- <span data-ttu-id="2f883-158">Semplificare la fisica</span><span class="sxs-lookup"><span data-stu-id="2f883-158">Simplify Physics</span></span>
- <span data-ttu-id="2f883-159">Allocazioni di memoria</span><span class="sxs-lookup"><span data-stu-id="2f883-159">Memory allocations</span></span>
- <span data-ttu-id="2f883-160">Algoritmi complessi, ad esempio</span><span class="sxs-lookup"><span data-stu-id="2f883-160">Complex algorithms (i.e</span></span> <span data-ttu-id="2f883-161">cinematica inversa, ricerca di percorsi</span><span class="sxs-lookup"><span data-stu-id="2f883-161">inverse kinematics, path-finding)</span></span>

### <a name="gpu-performance-recommendations"></a><span data-ttu-id="2f883-162">Suggerimenti sulle prestazioni della GPU</span><span class="sxs-lookup"><span data-stu-id="2f883-162">GPU performance recommendations</span></span>

#### <a name="understanding-bandwidth-vs-fill-rate"></a><span data-ttu-id="2f883-163">Informazioni sulla velocità di riempimento rispetto alla larghezza di banda</span><span class="sxs-lookup"><span data-stu-id="2f883-163">Understanding bandwidth vs fill rate</span></span>
<span data-ttu-id="2f883-164">Quando si esegue il rendering di un frame sulla GPU, un'applicazione è in genere limitata dalla larghezza di banda o dalla velocità di riempimento della memoria.</span><span class="sxs-lookup"><span data-stu-id="2f883-164">When rendering a frame on the GPU, an application is generally either bounded by memory bandwidth or fill rate.</span></span>

- <span data-ttu-id="2f883-165">La **larghezza di banda della memoria** è la velocità di lettura e scrittura che la GPU può eseguire dalla memoria</span><span class="sxs-lookup"><span data-stu-id="2f883-165">**Memory bandwidth** is the rate of reads and writes the GPU can perform from memory</span></span>
    - <span data-ttu-id="2f883-166">Per identificare le limitazioni della larghezza di banda, ridurre la qualità della trama e verificare se il framerate è migliorato.</span><span class="sxs-lookup"><span data-stu-id="2f883-166">To identify bandwidth limitations, reduce texture quality and check if framerate improved.</span></span>
    - <span data-ttu-id="2f883-167">In Unity, questa operazione può essere eseguita modificando la **qualità della trama** nelle impostazioni di **[qualità](https://docs.unity3d.com/Manual/class-QualitySettings.html)** **modifica** > **Impostazioni** > progetto.</span><span class="sxs-lookup"><span data-stu-id="2f883-167">In Unity, this can be done by changing **Texture Quality** in **Edit** > **Project Settings** > **[Quality Settings](https://docs.unity3d.com/Manual/class-QualitySettings.html)**.</span></span>
- <span data-ttu-id="2f883-168">La **velocità di riempimento** si riferisce alla velocità effettiva dei pixel sottoposti a rendering che possono essere disegnati al secondo dalla GPU.</span><span class="sxs-lookup"><span data-stu-id="2f883-168">**Fill rate** refers to the throughput of rendered pixels that can be drawn per second by the GPU.</span></span>
    - <span data-ttu-id="2f883-169">Per identificare le limitazioni della velocità di riempimento, ridurre la risoluzione dello schermo e verificare se il framerate è migliorato.</span><span class="sxs-lookup"><span data-stu-id="2f883-169">To identify fill rate limitations, decrease the display resolution and check if framerate improved.</span></span> 
    - <span data-ttu-id="2f883-170">In Unity, questa operazione può essere eseguita tramite la proprietà *[XRSettings. renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)*</span><span class="sxs-lookup"><span data-stu-id="2f883-170">In Unity, this can be done via the  *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* property</span></span>

<span data-ttu-id="2f883-171">La larghezza di banda della memoria comporta in genere ottimizzazioni per</span><span class="sxs-lookup"><span data-stu-id="2f883-171">Memory bandwidth generally involves optimizations to either</span></span>
1) <span data-ttu-id="2f883-172">riduzione delle risoluzioni di trama</span><span class="sxs-lookup"><span data-stu-id="2f883-172">decrease texture resolutions</span></span>
2) <span data-ttu-id="2f883-173">usare meno trame (ad esempio</span><span class="sxs-lookup"><span data-stu-id="2f883-173">utilize less textures (i.e</span></span> <span data-ttu-id="2f883-174">normali, speculari e così via)</span><span class="sxs-lookup"><span data-stu-id="2f883-174">normals, specular, etc)</span></span>

<span data-ttu-id="2f883-175">La velocità di riempimento si concentra principalmente sulla riduzione del numero di operazioni che devono essere calcolate per un pixel finale sottoposto a rendering.</span><span class="sxs-lookup"><span data-stu-id="2f883-175">Fill rate is primarily focused on reducing the number of operations that need to be computed for a final rendered pixel.</span></span> <span data-ttu-id="2f883-176">Esempi di questo genere rientrano nella riduzione</span><span class="sxs-lookup"><span data-stu-id="2f883-176">Examples of this commonly fall into reducing</span></span>
1) <span data-ttu-id="2f883-177">numero di oggetti di cui eseguire il rendering o il processo</span><span class="sxs-lookup"><span data-stu-id="2f883-177">number of objects to render/process</span></span>
2) <span data-ttu-id="2f883-178">numero di operazioni per shader</span><span class="sxs-lookup"><span data-stu-id="2f883-178">number of operations per shader</span></span>
3) <span data-ttu-id="2f883-179">numero di fasi GPU fino al risultato finale (Geometry shader, effetti di post-elaborazione e così via)</span><span class="sxs-lookup"><span data-stu-id="2f883-179">number of GPU stages to final result (geometry shaders, post-processing effects, etc)</span></span>
4) <span data-ttu-id="2f883-180">numero di pixel di cui eseguire il rendering (ovvero</span><span class="sxs-lookup"><span data-stu-id="2f883-180">number of pixels to render (i.e</span></span> <span data-ttu-id="2f883-181">risoluzione dello schermo)</span><span class="sxs-lookup"><span data-stu-id="2f883-181">display resolution)</span></span>

#### <a name="reduce-poly-count"></a><span data-ttu-id="2f883-182">Ridurre il numero di Poly</span><span class="sxs-lookup"><span data-stu-id="2f883-182">Reduce poly count</span></span>
<span data-ttu-id="2f883-183">I conteggi di poligoni più elevati comportano più operazioni per la GPU e la riduzione del numero di poligoni nella scena riduce la quantità di tempo per il rendering di tale geometria.</span><span class="sxs-lookup"><span data-stu-id="2f883-183">Higher polygon counts result in more operations for the GPU and reducing the number of polygons in your scene will reduce the amount of time to render that geometry.</span></span> <span data-ttu-id="2f883-184">Ci sono anche altri fattori da tenere presente nell'ombreggiatura della geometria che può essere ancora costosa, ma il conteggio dei poligoni è la metrica di base per determinare il costo di rendering di una scena.</span><span class="sxs-lookup"><span data-stu-id="2f883-184">There are other factors involved as well in shading the geometry that can still be expensive but polygon count is the base metric to determine how expensive a scene will be to render.</span></span>

#### <a name="limit-overdraw"></a><span data-ttu-id="2f883-185">Limite di sovralievo</span><span class="sxs-lookup"><span data-stu-id="2f883-185">Limit overdraw</span></span>

<span data-ttu-id="2f883-186">Un elevato livello di sovradisegnazione si verifica quando viene eseguito il rendering di più oggetti, ma non vengono visualizzati sullo schermo, perché sono nascosti da un altro oggetto, in genere più vicino, oggetto occlusione.</span><span class="sxs-lookup"><span data-stu-id="2f883-186">High overdraw occurs when multiple objects are rendered but not outputted to the screen as they are hidden by another, generally closer, occluding object.</span></span> <span data-ttu-id="2f883-187">Si supponga di esaminare un muro con più sale e geometria.</span><span class="sxs-lookup"><span data-stu-id="2f883-187">Imagine looking at a wall that had multiple rooms and geometry behind it.</span></span> <span data-ttu-id="2f883-188">Tutta la geometria verrebbe elaborata per il rendering, ma è necessario eseguire il rendering solo della parete opaca, perché occlude la visualizzazione di tutti gli altri contenuti.</span><span class="sxs-lookup"><span data-stu-id="2f883-188">All of the geometry would be processed for rendering but only the opaque wall really needs to be rendered as it occludes the view of all other content.</span></span> <span data-ttu-id="2f883-189">Ciò comporta una dispendiosa operazione non necessaria per la visualizzazione corrente.</span><span class="sxs-lookup"><span data-stu-id="2f883-189">This results in wasteful operations that are not needed for the current view.</span></span>

#### <a name="shaders"></a><span data-ttu-id="2f883-190">Shader</span><span class="sxs-lookup"><span data-stu-id="2f883-190">Shaders</span></span>

<span data-ttu-id="2f883-191">Gli shader sono piccoli programmi eseguiti sulla GPU e in genere determinano due passaggi importanti nel rendering:</span><span class="sxs-lookup"><span data-stu-id="2f883-191">Shaders are small programs that run on the GPU and generally determine two important steps in rendering:</span></span>
1) <span data-ttu-id="2f883-192">quali vertici dell'oggetto devono essere disegnati sullo schermo e dove si trovano nello spazio dello schermo, ad esempio</span><span class="sxs-lookup"><span data-stu-id="2f883-192">which object's vertices should be drawn on the screen and where they are in screen space (i.e</span></span> <span data-ttu-id="2f883-193">Vertex shader)</span><span class="sxs-lookup"><span data-stu-id="2f883-193">the Vertex shader)</span></span>
    - <span data-ttu-id="2f883-194">Il vertex shader viene in genere eseguito per ogni vertice per ogni GameObject</span><span class="sxs-lookup"><span data-stu-id="2f883-194">The Vertex shader is generally executed per vertex for every GameObject</span></span>
2) <span data-ttu-id="2f883-195">che cosa colora tali pixel, ad esempio</span><span class="sxs-lookup"><span data-stu-id="2f883-195">what to color those pixels (i.e</span></span> <span data-ttu-id="2f883-196">Pixel shader)</span><span class="sxs-lookup"><span data-stu-id="2f883-196">the Pixel shader)</span></span>
    - <span data-ttu-id="2f883-197">Il pixel shader viene eseguito per pixel per la trama di cui viene eseguito il rendering per il dispositivo presente</span><span class="sxs-lookup"><span data-stu-id="2f883-197">The Pixel shader is executed per pixel for the texture being rendered for device present</span></span>

<span data-ttu-id="2f883-198">In genere gli shader eseguono numerose trasformazioni e calcoli di illuminazione.</span><span class="sxs-lookup"><span data-stu-id="2f883-198">Typically shaders perform many transformations and lighting calculations.</span></span> <span data-ttu-id="2f883-199">Sebbene i modelli di illuminazione complessi, le ombre e altre operazioni possano generare risultati eccezionali, presentano anche un prezzo.</span><span class="sxs-lookup"><span data-stu-id="2f883-199">Although complex lighting models, shadows, and other operations can generate fantastic results, they also come with a price.</span></span> <span data-ttu-id="2f883-200">La riduzione del numero di operazioni calcolate negli shader può ridurre notevolmente il lavoro complessivo necessario per eseguire una GPU per fotogramma.</span><span class="sxs-lookup"><span data-stu-id="2f883-200">Reducing the number of operations computed in shaders can greatly reduce the overall work needed to be done by a GPU per frame.</span></span>

##### <a name="shader-coding-recommendations"></a><span data-ttu-id="2f883-201">Suggerimenti sulla codifica dello shader</span><span class="sxs-lookup"><span data-stu-id="2f883-201">Shader coding recommendations</span></span>

- <span data-ttu-id="2f883-202">Usare il filtro bilineare laddove possibile</span><span class="sxs-lookup"><span data-stu-id="2f883-202">Use bilinear filtering whenever possible</span></span>
- <span data-ttu-id="2f883-203">Ridisporre le espressioni in modo da usare funzioni intrinseche folli per eseguire un'operazione di moltiplicazione e un aggiunta allo stesso tempo</span><span class="sxs-lookup"><span data-stu-id="2f883-203">Rearrange expressions to use MAD intrinsics in order to do a multiply and an add at the same time</span></span>
- <span data-ttu-id="2f883-204">Precalcolare quanto più possibile sulla CPU e passare come costanti al materiale</span><span class="sxs-lookup"><span data-stu-id="2f883-204">Precalculate as much as possible on the CPU and pass as constants to the material</span></span>
- <span data-ttu-id="2f883-205">**Preferire le operazioni di trasferimento dal pixel shader al vertex shader**</span><span class="sxs-lookup"><span data-stu-id="2f883-205">**Favor moving operations from the pixel shader to the vertex shader**</span></span>
    - <span data-ttu-id="2f883-206">Generalmente il numero di vertici < < numero di pixel, ovvero</span><span class="sxs-lookup"><span data-stu-id="2f883-206">Generally the # of vertices << # of pixels (i.e</span></span> <span data-ttu-id="2f883-207">720p = = 921.600 pixel, 1080p = = 2.073.600 pixel e così via)</span><span class="sxs-lookup"><span data-stu-id="2f883-207">720p == 921,600 pixels, 1080p == 2,073,600 pixels, etc)</span></span>

#### <a name="remove-gpu-stages"></a><span data-ttu-id="2f883-208">Rimuovi fasi GPU</span><span class="sxs-lookup"><span data-stu-id="2f883-208">Remove GPU stages</span></span>
<span data-ttu-id="2f883-209">Gli effetti di post-elaborazione possono essere molto costosi e in genere inibiscono la velocità di riempimento dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="2f883-209">Post-processing effects can be very expensive and generally inhibit the fill rate of your application.</span></span> <span data-ttu-id="2f883-210">Sono incluse anche tecniche di anti-aliasing, ad esempio MSAA.</span><span class="sxs-lookup"><span data-stu-id="2f883-210">This also includes anti-aliasing techniques such as MSAA.</span></span> <span data-ttu-id="2f883-211">In HoloLens è consigliabile evitare completamente queste tecniche.</span><span class="sxs-lookup"><span data-stu-id="2f883-211">On HoloLens, it is recommended to avoid these techniques entirely.</span></span> <span data-ttu-id="2f883-212">Inoltre, quando possibile, è consigliabile evitare fasi aggiuntive dello shader, ad esempio geometria, scafo e compute shader.</span><span class="sxs-lookup"><span data-stu-id="2f883-212">Furthermore, additional shader stages such as geometry, hull, and compute shaders should be avoided when possible.</span></span>

## <a name="memory-recommendations"></a><span data-ttu-id="2f883-213">Consigli sulla memoria</span><span class="sxs-lookup"><span data-stu-id="2f883-213">Memory recommendations</span></span>
<span data-ttu-id="2f883-214">Un'allocazione eccessiva della memoria & operazioni di deallocazione possono avere effetti negativi sull'applicazione olografica, con prestazioni incoerenti, frame bloccati e altro comportamento dannoso.</span><span class="sxs-lookup"><span data-stu-id="2f883-214">Excessive memory allocation & deallocation operations can have adverse effects on your holographic application resulting in inconsistent performance, frozen frames, and other detrimental behavior.</span></span> <span data-ttu-id="2f883-215">È particolarmente importante comprendere le considerazioni sulla memoria durante lo sviluppo in Unity, perché la gestione della memoria è controllata dal Garbage Collector.</span><span class="sxs-lookup"><span data-stu-id="2f883-215">It is especially important to understand memory considerations when developing in Unity since memory management is controlled by the garbage collector.</span></span>

#### <a name="object-pooling"></a><span data-ttu-id="2f883-216">Pool di oggetti</span><span class="sxs-lookup"><span data-stu-id="2f883-216">Object pooling</span></span>

<span data-ttu-id="2f883-217">Il pool di oggetti è una tecnica comune per ridurre il costo delle allocazioni continue & le deallocazioni di oggetti.</span><span class="sxs-lookup"><span data-stu-id="2f883-217">Object pooling is a popular technique to reduce the cost of continuous allocations & deallocations of objects.</span></span> <span data-ttu-id="2f883-218">Questa operazione viene eseguita allocando un pool di grandi dimensioni di oggetti identici e riutilizzando le istanze disponibili inattive da questo pool invece di generare ed eliminare costantemente gli oggetti nel tempo.</span><span class="sxs-lookup"><span data-stu-id="2f883-218">This is done by allocating a large pool of identical objects and re-using inactive, available instances from this pool instead of constantly spawning and destroying objects over time.</span></span> <span data-ttu-id="2f883-219">I pool di oggetti sono ottimi per i componenti riutilizzabili con durata variabile durante un'app.</span><span class="sxs-lookup"><span data-stu-id="2f883-219">Object pools are great for re-useable components that have variable lifetime during an app.</span></span>

## <a name="see-also"></a><span data-ttu-id="2f883-220">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="2f883-220">See also</span></span>
- [<span data-ttu-id="2f883-221">Consigli sulle prestazioni per Unity</span><span class="sxs-lookup"><span data-stu-id="2f883-221">Performance recommendations for Unity</span></span>](performance-recommendations-for-unity.md)
- [<span data-ttu-id="2f883-222">Impostazioni consigliate per Unity</span><span class="sxs-lookup"><span data-stu-id="2f883-222">Recommended settings for Unity</span></span>](recommended-settings-for-unity.md)
